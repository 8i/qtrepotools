#! /usr/bin/perl
# Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies).
# Copyright (C) 2014 Petroules Corporation.
# Contact: http://www.qt-project.org/legal
#
# You may use this file under the terms of the 3-clause BSD license.
# See the file LICENSE from this package for details.
#

use strict;
use warnings;
use Cwd;

if ($#ARGV < 0 or $#ARGV > 1 || ($#ARGV == 1 && $ARGV[1] !~ /^(strict|gerrit)$/)) {
    print STDERR "Usage: $0 <sha1> [strict]\n";
    exit 2;
}
my $sha1 = $ARGV[0];
my $gerrit = ($#ARGV == 1 && $ARGV[1] eq "gerrit");
my $strict = $gerrit || ($#ARGV == 1 && $ARGV[1] eq "strict");

my $repo = getcwd();
$repo =~ s,/?\.git$,,;
$repo =~ s,^.*/,,;
my %config = ();
for (`git config --list`) {
    if (/^sanity\.\Q$repo\E\.([^=]+)=(.*$)/) {
        $config{$1} = $2;
    }
}

my %cfg = ();
if (defined $ENV{GIT_PUSH}) {
    foreach my $c (split ",", $ENV{GIT_PUSH}) {
        $cfg{$c} = 1;
    }
}
if (defined $config{flags}) {
    foreach my $c (split ",", $config{flags}) {
        $cfg{$c} = 1;
    }
}
my (%watch_files, %watch_people);
for my $key (keys %config) {
    $watch_files{$1} = $config{$key} if ($key =~ /^watches\.([^.]+)\.files/);
    $watch_people{$1} = $config{$key} if ($key =~ /^watches\.([^.]+)\.people/);
}
my $fail = 0;
my $printed = $gerrit;
my $complained = 0;
our $file = "";  # 'our' for usage of 'local'
my $fail_file = "-";
my $summary;
my ($lpfx, $elpfx) = ($gerrit ? ("", "\n") : ("***   ", "***\n"));
my %footnotes;

sub printerr()
{
  die "cannot run git: ".$! if ($? < 0);
  die "git crashed with signal ".$? if ($? & 127);
  die "git exited with status ".($? >> 8) if ($?);
}

sub complain($$;$)
{
    my ($msg, $key, $level) = @_;
    my $pfx;

    if (!$printed) {
        $summary =~ s/^(.{50}).{5,}$/$1\[...]/;
        print "***\n*** Suspicious changes in commit ".$sha1." (".$summary."):\n";
        $printed = 1;
    }
    $complained = 1;
    if (length($file)) {
        if ($file ne $fail_file) {
            print $elpfx.$lpfx.$file.":\n";
            $fail_file = $file;
        }
        $pfx = $lpfx."  - ";
    } else {
        if ($file ne $fail_file) {
            print $elpfx;
            $fail_file = "";
        }
        $pfx = $lpfx."- ";
    }
    $level = 0 if (!defined($level) || ($level < 0 && $strict && length($key)));
    if ($level >= 0) {
        $fail = $level + 1 if ($level >= $fail);
        if ($gerrit) {
            print $pfx.$msg."\n";
        } else {
            print $pfx.$msg." (key \"".$key."\")\n";
        }
    } else {
        print $pfx."Hint: ".$msg."\n";
    }
}

my $lineno = 0;
my $clike = 0;
my $qmake = 0;
my $iswip = defined($cfg{wip});
my $badrev = 0;
my $badsign = 0;
my $badtask = 0;
my $badid = defined($cfg{changeid});
my $badurl = defined($cfg{url});
my $badlog = defined($cfg{log});
my $spell_check = !defined($cfg{spell});
my $parents = 0;
my ($inchangelog, $changelog) = (0, "");
my ($footer, $cherry) = (0, 0);
my ($badauthor, $badcommitter) = (0, 0);
my ($revert1, $revert2, $nonrevert) = (0, 0, 0);

# Load spelling errors dataset if available
our %MISTAKES;
our %MISTAKES_BASE;
BEGIN {
    eval { require Lingua::EN::CommonMistakes };
    if (!$@) {
        # Load US-specific and non-US-specific mistakes so we can give a hint
        # about US vs British English where appropriate
        Lingua::EN::CommonMistakes->import(qw(:no-punct %MISTAKES_BASE));
        Lingua::EN::CommonMistakes->import(qw(:american :no-punct %MISTAKES));
    }
}

my @spell_fails;

sub complain_spelling()
{
    if (@spell_fails) {
        complain("Possible spelling errors", "spell");
        for my $sf (@spell_fails) {
            print $lpfx."    ".$sf."\n";
        }
        @spell_fails = ();
    }
}

# Given a line of text, searches for likely spelling errors.
sub check_spelling()
{
    my %seen;
    my (@words) = split(/\b/);
    foreach my $word (@words) {
        $word = lc $word;
        next if $seen{$word};
        $seen{$word} = 1;
        if (my $correction = $MISTAKES{$word}) {
            if (!$MISTAKES_BASE{$word}) {
                $correction .= ' [*]';
                $footnotes{'[*] Please note, Qt prefers American English.'} = 1;
            }
            push @spell_fails, $lineno.": $word -> $correction";
        }
    }
}

sub check_apple_terminology()
{
    if ($clike) {
        if (/\bQ_OS_MAC\b.*&&.*!.*\bQ_OS_IOS\b/) {
            complain("$lineno: Use of deprecated idiom 'defined(Q_OS_MAC) && !defined(Q_OS_IOS)';" .
                      " use Q_OS_OSX instead", "terminology");
        }

        # Not invalid, but remind people about how the unfortunately named Q_OS_MAC must be used
        if (/\bQ_OS_MAC\b/) {
            complain("$lineno: Q_OS_MAC covers both OS X and iOS; if you meant only OS X, use Q_OS_OSX",
                      "", -1);
        }

        if (/\bQ_OS_MACX\b/) {
            complain("$lineno: Using deprecated define Q_OS_MACX; use Q_OS_OSX instead", "terminology");
        }
    } elsif ($qmake) {
        # check qmake scopes
        if (/\bmac\s*:\s*!\s*ios\b/) {
            complain("$lineno: Use of deprecated idiom 'mac:!ios', use 'osx' instead",
                      "terminology");
        }

        # Not invalid, but remind people about how the unfortunately named 'mac' must be used
        if (/\bmac\b/) {
            complain("$lineno: Possible use of qmake scope 'mac': this covers both OS X and iOS;" .
                      " if you meant only OS X, use 'osx'", "", -1);
        }

        # Match the word macx but avoid matching macx- and macx* since these are valid for mkspecs
        if (/\bmacx\b(?![-*])/) {
            complain("$lineno: Using deprecated qmake scope 'macx'; use 'osx' instead",
                      "terminology");
        }
    }

    # Note that Mac(intosh)? is the name of the hardware that runs the OS X operating system and is
    # valid for use, however users are likely to use Mac(intosh)? to incorrectly refer to the OS so
    # we'll still flag it
    if (/\bmac(([\s_-]*os)([\s_-]*x)?)?\b/i or /\bmacintosh\b/i) {
        complain("$lineno: Possible incorrect use of Apple-related terminology", "", -1);
    }
}

open MSG, "git log -1 --pretty=raw ".$sha1." |" or die "cannot run git: $!";
while (<MSG>) {
    chomp;
    if (!s/^    //) {
        if (/^parent /) {
            $parents++ ;
        } elsif (/^author .*\.\(none\)/) {
            $badauthor = 1;
        } elsif (/^commiter .*\.\(none\)/) {
            $badcommitter = 1;
        }
        next
    }
    $lineno++;
    if ($lineno == 1) {
        $summary = $_;
        $revert1 = 1 if (/^Revert ".*"$/);
        if (/^revert(ed|ing)? (commit )?[0-9a-f]{7,40}\.?$/i) {
            complain("Summary of revert mentions only SHA1", "log");
        }
        if (/\bQT[A-Z]+-\d+\b/) {
            complain("Bug reference in summary", "log");
        }
        if (!$iswip && $parents < 2 && /\bWIP\b|\*{3}|^(?:squash|fixup)! |^(.)\1*$/i) {
            complain("Apparently pushing a Work In Progress", "wip", 1);
        } elsif (!$iswip && !$badlog && length($_) < 7) {
            complain("Log message summary is too short", "log");
        } elsif (!$badlog && !$revert1 && length($_) > 120) {
            complain("Log message summary is excessively long", "log");
        } elsif ($parents < 2 && !$revert1 && length($_) > 70) {
            complain("Aim for shorter log message summaries", "", -1);
        }
    } else {
        if (/^This reverts commit [[:xdigit:]]{40}\.?$/) {
            $revert2 = 1;
        } elsif (!/^[-\w]+:|^$/) {
            $nonrevert = 1;
        }
        if ($lineno == 2) {
            if (!$badlog && $_ ne "") {
                complain("2nd line of log message is not empty", "log");
            }
        } elsif ($_ eq "") {
            $cherry = 0;
            $inchangelog = 0;
            # Empty line following footer(s).
            $footer = 2 if ($footer == 1);
        } elsif ($cherry) {
            $cherry = 0 if (/\)/);
        } else {
            if (!$badrev && /^Reviewed-by:/i) {
                $badrev = 1;
            }
            if (!$badsign && /^Signed-off-by:/i) {
                $badsign = 1;
            }
            if (!$badtask && /^Task-number:/i && !/^Task-number:/) {
                $badtask = 1;
                complain("Capitalization of \"Task-number\" is wrong", "");
            }
            if (!$badid && /\bI[0-9a-f]{40}\b/ && !/^Change-Id: /) {
                $badid = 1;
                complain("Gerrit change id outside Change-Id footer", "changeid");
            }
            if (!$badurl && /\bhttps?:\/\/(bugreports\.qt-project\.org\/browse\/|codereview\.qt-project\.org\/(\#change,|\#\/c\/)?\d+)/) {
                $badurl = 1;
                complain("URL pointing to Gerrit or JIRA", "url");
            }
            my $ftr = 0;
            if (/^\((partial(ly)? )?(cherry[- ]pick|(back)?port)(ed)? /) {
                $cherry = 1 if (!/\)/);
                # Some bad footers are ok above cherry-pick lines.
                $badrev = 0;
                $badsign = 0;
                # cherry-pick lines count as footers as well.
                $ftr = 1;
            } elsif (/^[A-Z][a-z]+(-[A-Za-z][a-z]+)+: /) {
                $ftr = 1;
            } elsif (/^(\[change-?log\]|change-?log: )/i) {
                $inchangelog = 1;
            }
            if ($inchangelog) {
                if (($ftr || $footer == 1) && !defined($cfg{changelog})) {
                    complain("No empty line between ChangeLog and footers", "changelog");
                }
                $changelog .= "\n".$_;
            }
            if ($ftr) {
                if ($footer == 0) {
                    # Footer following non-footer
                    $footer = 1;
                } elsif ($footer == 2) {
                    # Footer following empty line(s) following footer(s)
                    $footer = 3;
                }
            } else {
                # Non-footer resets the state, assuming it was a false alert.
                # Possibly we should make a different complaint instead.
                $footer = 0;
            }
        }
    }

    check_spelling() if ($spell_check);
    check_apple_terminology();
}
close MSG;
printerr;

if ($revert1 && $revert2 && !$nonrevert) {
    complain("Revert without explanation", "revert", 1);
}
# These need to be delayed, because at the time they are found the subject is not known yet.
if ($badauthor) {
    complain("Bogus author email", "email", 1);
}
if ($badcommitter) {
    complain("Bogus committer email", "email", 1);
}
if ($badrev && !defined($cfg{revby})) {
    complain("Bogus Reviewed-by footer", "revby", 1);
}
if ($badsign) {
    complain("Unnecessary Signed-off-by footer", "", -1);
}
if ($footer == 3 && !defined($cfg{footer})) {
    complain("Empty lines between footers", "footer");
}
if (length($changelog) && !defined($cfg{changelog})) {
    complain("Bad form of [ChangeLog] tag", "changelog") if ($changelog !~ /^\n\[ChangeLog\]/s);
    complain("Missing space between ChangeLog tags and text", "changelog") if ($changelog !~ /\]\s[^\[]/s);
    complain("JIRA task referenced from ChangeLog", "changelog") if ($changelog =~ /\[QT[A-Z]+-\d+\]/s);
    complain("Current repository referenced from ChangeLog", "changelog") if ($changelog =~ /\[$repo\]/si);
}

{
    local $file = 'log message';
    complain_spelling();
}

my $chunk = 0;
my @addi = ();
my @deli = ();
my $nonws;
my $ws;
my $mixws_check = 0;
my %ws_lines = (); # hash of lists
my $braces = 0;
my $open_key = qr/\s*#\s*if|.*{/;
my $close_key = qr/\s*#\s*endif|.*}/;
my $kill_all_ws = qr/\s+((?:\"(?:\\.|[^\"])*\"|\S)+)/; # Collapse all whitespace not inside strings.
my $kill_nl_ws = qr/((?:\"(?:\\.|[^\"])*\"|\S)+)\s+/; # Collapse all non-leading whitespace not inside strings.

$lineno = 0;

sub flushChunk()
{
    my $loc_nonws = 0;
    my $nlonly = 1;
    my ($ai, $di) = (0, 0);
    while (!$loc_nonws) {
        my ($a, $d) = ("", "");
        while ($ai < @addi) {
            $a = $addi[$ai++];
            $a =~ s/\s+$//;
            if (length($a)) {
                $nlonly = 0;
                last;
            }
        }
        while ($di < @deli) {
            $d = $deli[$di++];
            $d =~ s/\s+$//;
            if (length($d)) {
                $nlonly = 0;
                last;
            }
        }
        last if (!length($a) && !length($d));

        $a =~ /^$close_key/o and $braces--;
        $d =~ /^$close_key/o and $braces++;
        if ($braces) {
            $a =~ s/$kill_nl_ws/$1/go;
            $d =~ s/$kill_nl_ws/$1/go;
        } else {
            $a =~ s/$kill_all_ws/$1/go;
            $d =~ s/$kill_all_ws/$1/go;
        }
        $loc_nonws = 1 if ($a ne $d);
        $a =~ /^$open_key/o and $braces++;
        $d =~ /^$open_key/o and $braces--;
    }
    while ($ai < @addi) {
        my $a = $addi[$ai++];
        $a =~ /^$close_key/o and $braces--;
        $a =~ /^$open_key/o and $braces++;
    }
    while ($di < @deli) {
        my $d = $deli[$di++];
        $d =~ /^$close_key/o and $braces++;
        $d =~ /^$open_key/o and $braces--;
    }
    if ($loc_nonws) {
        $nonws = 1;
    } elsif (!$nlonly) {
        $ws = 1;
        push @{$ws_lines{$file}}, $lineno - $#addi;
    }
    @addi = @deli = ();
    $chunk = 0;
}

sub formatSize($)
{
    my $sz = shift;
    if ($sz >= 10 * 1024 * 1024) {
        return int($sz / (1024 * 1024))."MiB";
    } elsif ($sz >= 10 * 1024) {
        return int($sz / 1024)."KiB";
    } else {
        return int($sz)."B";
    }
}

sub isExe($)
{
    my $sha = shift;
    my $type = `git cat-file -p $sha | file -b -`;
    return $type =~ /^(ELF|PE32) /;
}

my @style_fails = ();

sub styleFail($)
{
    my $why = shift;
    push @style_fails, $lineno.": ".$why;
}

my $no_copyright = 0;

sub flushFile()
{
    if ($no_copyright && $lineno > ($file =~ /^tests\/.*\.qml$/ ? 20 : 10)) {
        complain("Missing copyright header", "copyright");
    }
    complain_spelling();
    if (@style_fails) {
        complain("Style issues", "style", -1);
        for my $sf (@style_fails) {
            print $lpfx."    ".$sf."\n";
        }
        @style_fails = ();
    }
}

my $merge;
my $new_file;
my $maybe_bin;
my $is_special;
my $size;
my $check_gen = 0;
my $crlf_fail;
my $in_plus;
my $conflict_fail;
my $tabs_check;
my $ws_check;
my $tsv_check;
my $eof_check;
my $ctlkw_check;
open DIFF, "git diff-tree --patience --no-commit-id --diff-filter=ACMR --src-prefix=\@old\@/ --dst-prefix=\@new\@/ --full-index -r -U100000 --cc -C -l1000 --root ".$sha1." |" or die "cannot run git: $!";
while (<DIFF>) {
    if (/^-/) {
        if ($mixws_check) {
            /^--- / and next;
            push @deli, substr($_, 1);
            $chunk = 1;
        }
        $in_plus = 0;
        next;
    }
    if ($lineno < 50) {
        if ($no_copyright && /Copyright/) {
            $no_copyright = 0;
        }
        if ($check_gen && /All changes made in this file will be lost|This file is automatically generated|DO NOT EDIT|DO NOT delete this file|[Gg]enerated by|uicgenerated|produced by gperf|made by GNU Bison/) {
            complain("Adding generated file", "generated") if ($new_file && !defined($cfg{generated}));
            $ws_check = 0;
            $check_gen = 0;
        }
    }
    if (/^\+/) {
        if (/^\+\+\+ /) {
            # This indicates a text file; binary files have "Binary files ... and ... differ" instead.
            $maybe_bin = 0;
            if ($file =~ /(~|\.(old|bak))$/i) {
                complain("Adding backup file", "backup") if ($new_file && !defined($cfg{backup}));
                $ws_check = 0;
            } elsif ($file =~ /\.(prl|la|pc|ilk)$/i) {
                complain("Adding build artifact", "generated") if ($new_file && !defined($cfg{generated}));
                $ws_check = 0;
            } elsif ($file !~ /\.qmltypes$/i) {
                $check_gen = 1;
            }
            next;
        }
        $lineno++;
        if ($merge) {
            # Consider only lines which are new relative to both parents, i.e., were added during the merge.
            s/^\+\+// or next;
        } else {
           $_ = substr($_, 1);
            if ($mixws_check) {
                push @addi, $_;
                $chunk = 1;
            }
        }
        $in_plus = 1;
        if (!$crlf_fail && /\r\n$/) {
            $crlf_fail = 1;
            complain("CRLF line endings", "crlf");
        }
        if (!$conflict_fail && /^(?:[<>=]){7}( |$)/) {
            complain("Unresolved merge conflict", "conflict");
            $conflict_fail = 1;
        }
        if ($ws_check) {
            if ($tsv_check) {
                styleFail("Mixing spaces with TABs") if (/^ +\t|\t +/);
            } else {
                styleFail("Space indent followed by a TAB character") if (/^ +\t/);
                styleFail("TAB character in non-leading whitespace") if (/\S *\t/);
                styleFail("Trailing whitespace") if (/[ \t]\r?\n$/);
                if ($tabs_check) {
                    styleFail("Leading tabs") if (/^\t+/);
                    if ($ctlkw_check) {
                        styleFail("Flow control keywords must be followed by a single space")
                           if (/\b(if|for|foreach|Q_FOREACH|while|do|switch)(|  +)\(/);
                    }
                }
            }
        }
        check_spelling() if ($spell_check);
        check_apple_terminology();
    } else {
        flushChunk() if ($chunk);
        if (/^ /) {
            $lineno++ if (!$merge || !/^ -/);
            $in_plus = 0;
            next;
        }
        if ($eof_check && !$is_special && /^\\ No newline/) {
            if ($in_plus) {
                complain("No newline at end of file", "fileend") if (!defined($cfg{fileend}));
            }
            next;
        }
        if ($merge ? /^\@\@\@ -\S+ -\S+ \+(\d+)/ : /^\@\@ -\S+ \+(\d+)/) {
            $lineno = $1 - 1;
            next;
        }
        if (/^diff /) {
            flushFile();
            if (/^diff --git \@old\@\/.+ \@new\@\/(.+)$/) {
                $merge = 0;
            } elsif (/^diff --cc (.+)$/) {
                $merge = 1;
            } else {
                print STDERR "Warning: cannot parse diff header '".$_."'\n";
                next;
            }
            $file = $1;
            #print "*** got file ".$file.".\n";
            $clike = ($file =~ /\.(c|cc|cpp|c\+\+|cxx|qdoc|m|mm|h|hpp|hxx|cs|java|js|qs|qml|g|y|ypp|pl|glsl)$/i);
            $qmake = ($file =~ /\.pr[filo]$/i);
            for my $key (keys %watch_files) {
                if ($file =~ /^$watch_files{$key}$/) {
                    complain("Changing this file is risky. Please add $watch_people{$key} as reviewer(s).", "", -1);
                }
            }
            my $foreign = ($file =~ /\/3rdparty\//);
            $new_file = 0;
            $maybe_bin = 0;
            $is_special = 0;
            $crlf_fail = defined($cfg{crlf});
            $in_plus = 0;
            $mixws_check = !$merge && !$foreign && $clike && !defined($cfg{mixws});
            $ws_check = !defined($cfg{style}) && !$foreign && ($file !~ /\.(ts|diff|patch)$|^\.gitmodules$/);
            $tsv_check = $ws_check && ($file =~ /((^|\/)objects\.map$|\.tsv$)/);
            $tabs_check = $ws_check && !$tsv_check && !defined($cfg{tabs}) && ($file !~ /((^|\/)Makefile\b|debian[.\/]rules|\.(plist(\.[^.\/]+)?|def|spec|changes|[xn]ib|storyboardc?)$)/);
            $ctlkw_check = $tabs_check && $clike;
            $eof_check = ($file !~ /\.plist(\.[^.\/]+)?$/); # Xcode consistently forgets the trailing newline
            # .ts files usually contain languages other than English
            $spell_check = !defined($cfg{spell}) && !$foreign && ($file !~ /\.ts$/i);
            $conflict_fail = defined($cfg{conflict});
            $braces = 0;
            $check_gen = 0;
            $no_copyright = 0;
            next;
        }
        if ($maybe_bin && /^Binary files /) {
            if ($new_file) {
                if (!defined($cfg{generated}) && ($file =~ /\.(obj|o|lib|a|dll|so|exe|exp|qm|pdb|idb|suo)$/i || isExe($maybe_bin))) {
                    complain("Adding build artifact", "generated");
                }
            } else {
                if (!defined($cfg{giant}) && $size > (2 << 20)) {
                    complain("Changing huge binary file (".formatSize($size)." > 2MiB)", "giant", 1);
                }
            }
            next;
        }
        if ($_ eq "new file mode 160000\n" || $_ eq "new file mode 120000\n") {
            $is_special = 1;
            next;
        }
        if (!$is_special && /^index ([\w,]+)\.\.(\w+)(?! 160000)( |$)/) {
            my ($old_trees, $new_tree) = ($1, $2);
            #print "*** got index $old_trees $new_tree.\n";
            $size = `git cat-file -s $new_tree`;
            my $issrc = $clike || ($file =~ /\.(s|asm|pas|l|m4|bat|cmd|sh|py|php|qdoc(conf)?)$/i);
            if ($old_trees =~ /^0{40}(,0{40})*$/) {
            #print "*** adding ".$file.".\n";
                if (!$conflict_fail && $file =~ /\.(BACKUP|BASE|LOCAL|REMOTE)\.[^\/]+$/) {
                    complain("Adding temporary file from merge conflict resolution", "conflict", 1);
                    $conflict_fail = 1;
                }
                if (!defined($cfg{alien}) && $file =~ /\.(sln|vcproj|vcxproj|user)$/i) {
                    complain("Warning: Adding alien build system file", "alien");
                }
                if ($size > (2 << 20)) {
                    if (!defined($cfg{giant})) {
                        complain("Adding huge file (".formatSize($size)." > 2MiB)", "giant", 1);
                    }
                } elsif ($size > 51200 && !$issrc && !defined($cfg{size})) {
                    complain("Warning: Adding big file (".formatSize($size)." > 50KiB)", "size");
                }
                $size = 0;
                $new_file = 1;
                $no_copyright = $issrc && $file !~ /\.qdocconf$/i;
            } elsif ($size > 20000 && !$issrc && !defined($cfg{size})) {
                my $old_size = 0;
                for my $old_tree (split(/,/, $old_trees)) {
                    my $osz = `git cat-file -s $old_tree`;
                    $old_size = $osz if ($osz > $old_size);
                }
                if ($size > $old_size * 3 / 2) {
                    complain("Warning: Increasing file size by more than 50% (".
                                formatSize($old_size)." => ".formatSize($size).")", "size");
                }
            }
            $maybe_bin = $new_tree;
            next;
        }
    }
}
close DIFF;
printerr;
flushFile();
if ($mixws_check) {
    flushChunk() if ($chunk);
    if ($nonws and $ws) {
        $file = "";
        complain("Mixing whitespace-only changes with other changes", "mixws", -1);
        for my $fn (sort keys %ws_lines) {
            print $lpfx."  WS-only in ".$fn.": ".join(", ", @{$ws_lines{$fn}})."\n";
        }
    }
}

if (%footnotes) {
    print $elpfx;
    for my $fn (sort keys %footnotes) {
        print $lpfx.$fn."\n";
    }
}

if ($complained) {
    print $elpfx.$lpfx."See http://qt-project.org/wiki/Early-Warning-System for explanations.\n";
}

exit ($gerrit ? (!$fail ? 11 : (10 - $fail)) : $fail)
