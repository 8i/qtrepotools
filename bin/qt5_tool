#!/usr/bin/perl -w
####################################################################################################
#
# Helper script for Qt 5
#
# Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
# Contact: Nokia Corporation (qt-info@nokia.com)
#
####################################################################################################

############################################################################################
#
# Convenience script working with a Qt 5 repository.
#
# Feel free to add useful options!
#
# The intention is that this works with the old Perl used for Symbian as well:
# - Variables should not shadow others.
# - Some functions are just broken  (abs_path()),etc.
############################################################################################

use strict;

use Getopt::Long;
use File::Basename;
use Cwd;
use File::Spec;
use File::Copy;
use POSIX;
use IO::File;
use File::Path;

my $CLEAN=0;
my $DOC=0;
my $PULL=0;
my $BUILD=0;
my $MAKE=0;
my $RESET=0;
my $DIFF=0;
my $BOOTSTRAP=0;
my $STATUS=0;
my $UPDATE=0;
my $REBUILD_CONFIGURE=0;
my $optModuleBranchArgument;
my $optGerritModule;
my $optCommitHook;
my $gitoriousURL = 'git://gitorious.org/qt/qt5.git';
my $codeReviewHost = 'codereview.qt-project.org';
my $codeReviewPort = 29418;
my $configFile = '.qt5_tool';

my $USAGE=<<EOF;
Usage: qt5_tool [OPTIONS]

Utility script for working with Qt 5 modules.

Feel free to extend!

Options:
  -d  Diff (over all modules, relative to root)
  -s  Status
  -r  Reset hard
  -c  Clean
  -u  Update
  -p  Pull (for development only)
  -b  Build (configure + build)
  -m  Make
  -o  [D]ocumentation
  -q  Quick bootstrap a new checkout under current folder.
  -w  Windows: Rebuild configure.exe (requires MSVC setup)
  -g <module> Set up gerrit for the module.
  -t <module> Set up a tracking branch for the module. By default, this is
              staging/master. It is possible the specify the branch by appending
              :remote-branch to the module parameter, for example:
              qtbase:origin/refactor
  -h <hook>   Path to commit hook for -s.

Example use cases:
  qt5_tool -c -u -b     Clean, update and build for nightly builds
  qt5_tool -d           Generate modules diff relative to root directory
  qt5_tool -r           Reset --hard of repo.

qt_tool can be configured by creating a configuration file \$HOME/$configFile in
the format key=value. It is possible to use repository-specific values by
adding a key postfixed by a dash and the repository folder base name.
Use 'true', '1' for Boolean keys.
Supported keys:

nokiaDeveloper:     Nokia Developer mode (Boolean)
initArguments:      Arguments to init-repository for -q. Example:
                    [--berlin-|--brisbane-|--]nokia-developer
codeReviewUser:     User name for code review (Gerrit)
configureArguments: Arguments to configure
shadowBuildPostfix: Postfix to use for shadow build directory.
forceModules:       A list of modules (like "qtbase qtscript") that will be
                    built using 'make -k' if the global 'make' fails.
Example:
shadowBuildPostfix=-build
shadowBuildPostfix-qt-5special=-special-build

specifies that for a checkout in '/home/user/qt-5', shadow builds are to be
done in '/home/user/qt-5-build'. It is overridden by a value for the checkout
'/home/user/qt-5special', which would result in '/home/user/qt-5-special-build'
EOF

my %preferredBranches = (
#    'qtwebkit' , 'qt-modularization-base'
);

# --------------- Detect OS

my ($OS_LINUX, $OS_WINDOWS, $OS_MAC)  = (0, 1, 2);
my $os = $OS_LINUX;
if (index($^O, 'MSWin') >= 0) {
    $os = $OS_WINDOWS;
} elsif (index($^O, 'darwin') >= 0) {
   $os = $OS_MAC;
}

# -- Convenience for path search.
#    There is File::Which, but not by default installed on Linux.

sub which
{
    my ($needle) = @_;
    my $sep = $os == $OS_WINDOWS ? ';' : ':';
    my @needles = ($needle);
    push(@needles, $needle . '.exe', $needle . '.bat', $needle . '.cmd') if $os == $OS_WINDOWS;
    foreach my $path (split(/$sep/, $ENV{'PATH'})) {
        foreach my $n (@needles) {
            my $binary = File::Spec->catfile($path, $n);
            return $binary if (-f $binary);
        }
    }
    return undef;
}

# -- Locate an utility (grep, scp, etc) in MSYS git. This is specifically
#    for the setup case in which only git.cmd and not the utilities are in
#    the path. We then look at the git.cmd and return ..\bin\<utility>.exe.
sub msysGitUtility
{
#   -- Look for 'git.cmd' and cd ..\bin
    my ($git, $utility) = @_;
    if ($git =~ /.cmd$/i) {
        my $msysGitBinFolder = File::Spec->catfile(dirname(dirname($git)), 'bin');
        return File::Spec->catfile($msysGitBinFolder, $utility . '.exe');
    }
    return $utility;
}

my $qmakeSpec = $ENV{'QMAKESPEC'};
my $minGW = $os == $OS_WINDOWS && defined($qmakeSpec) && index($qmakeSpec,'g++') > 0;
my $make = 'make';
$make = $minGW ?  'mingw32-make' : 'nmake' if ($os == $OS_WINDOWS);

my @makeArgs = $os == $OS_WINDOWS && !$minGW ? () : ('-s');

my $git = which('git'); # TODO: Mac, Windows special cases?
die ('Unable to locate git') unless defined $git;

my $makeForceArg = $os == $OS_WINDOWS && !$minGW ? '/k' : '-k';

my $rootDir = '';
my $baseDir = '';
my $home = $os == $OS_WINDOWS ? ($ENV{'HOMEDRIVE'} . $ENV{'HOMEPATH'}) : $ENV{'HOME'};

# -- Set a HOME variable on Windows such that scp. etc. feel at home (locating .ssh).
$ENV{'HOME'} = $home if ($os == $OS_WINDOWS && not defined $ENV{'HOME'});

my $user = $os == $OS_WINDOWS ? $ENV{'USERNAME'} : $ENV{'USER'};
$configFile = File::Spec->catfile($home, $configFile);

my @MODULES = ();

my $nokiaDeveloperConfigKey = 'nokiaDeveloper';

# --- Execute a command and print to log.
sub execute
{
    my @args = @_;
    print '### [',basename(getcwd()),'] ', join(' ', @args),"\n";
    my $rc = system(@args);
    die ($args[0] . ' failed ' . $rc . ':' . $!) if $rc != 0;
}

# --- Prompt for input with a default

sub prompt
{
    my ($promptText, $defaultValue) = @_;
    print $promptText,' [', $defaultValue, ']:';
    my $userInput = <STDIN>;
    chomp ($userInput);
    return $userInput eq '' ? $defaultValue : $userInput;
}

# --- Fix a diff line from a submodule such that it can be applied to
#     the root Qt 5 directory, that is:
#     '--- a/foo...' -> '--- a/<module>/foo...'

sub fixDiff
{
   my ($line, $module) = @_;
   if (index($line, '--- a/') == 0 || index($line, '+++ b/') == 0) {
       return substr($line, 0, 6) . $module . '/' . substr($line, 6);
   }
   if (index($line, 'diff --git ') == 0) {
       $line =~ s| a/| a/$module/|;
       $line =~ s| b/| b/$module/|;
   }
   return $line;
}

# ---- Generate a diff from all submodules such that it can be applied to
#      the root Qt 5 directory.

sub diff
{
    my $totalDiff = '';
    my ($rootDir,$modArrayRef) = @_;
    foreach my $MOD (@$modArrayRef) {
     chdir($MOD) or die ('Failed to chdir from' . $rootDir . ' to "' . $MOD . '":' . $!);
     my $diffOutput = `"$git" diff`;
     foreach my $line (split(/\n/, $diffOutput)) {
         chomp($line);
         $totalDiff .= fixDiff($line, $MOD);
         $totalDiff .= "\n";
     }
     chdir($rootDir);
  }
  return $totalDiff;
}

# ---- Run git in root and module folders.
#      Do not use 'git submodules foreach' to be able to work on partially corrupt repositories

sub runGit
{
    my ($argListRef, $keepGoing) = @_;
    my $argString = join(' ', @$argListRef);
    print 'Running ', $argString, "\n";
    my $runRC = execute($git, @$argListRef);
    if ($runRC) {
       if ($keepGoing) {
          warn($argString . ' failed in root.');
       } else {
          die ($argString . ' failed in root.');
       }
    }
    foreach my $MOD (@MODULES) {
        chdir($MOD) or die ('Failed to chdir from' . $rootDir . ' to "' . $MOD . '":' . $!);
        my $modRunRC = execute($git, @$argListRef);
        if ($modRunRC) {
            if ($keepGoing) {
                warn($argString . ' failed in ' . $MOD);
            } else {
               die ($argString . ' failed in ' . $MOD);
            }
           $runRC = 1;
        }
        chdir($rootDir);
    }
    return $runRC;
}

# ---- Read a value from a configuration file of the form key=value.

sub readConfigFile
{
    my ($fileName, $key) = @_;

    my $configLine = '';
    my $configFile = new IO::File('<' . $fileName) or return $configLine;
    while (my $line = <$configFile>) {
        chomp($line);
        if ($line =~ /^\s*$key\s*=\s*(.*)$/) {
           $configLine .= $1;
           last;
        }
    }
    $configFile->close();
    return $configLine;
}

# ---- Read a value from a git config line.

sub readGitConfig
{
    my ($module, $key) = @_;
    return readConfigFile(File::Spec->catfile($rootDir, $module, '.git', 'config'), $key);
}

# ---- MinGW: Remove git from path (prevent sh.exe from throwing off mingw32-make).

sub winRemoveGitFromPath
{
    my @path = split(/;/, $ENV{'PATH'});
    my @cleanPath = grep(!/git/, @path);
    if (@path != @cleanPath) {
        print 'Removing git from path...';
        $ENV{'PATH'} = join(';', @cleanPath);
    }
}

# ---- Set up a tracking branch
sub initTrackingBranch
{
    my ($branchName, $remoteBranchName) = @_;
    my $strc = execute($git, ('fetch', '--all'));
    die 'fetch failed.' if $strc;
    print 'Switching to ', $branchName, ' from ', $remoteBranchName, "\n";
    $strc = execute($git, ('branch', '--track', $branchName, $remoteBranchName));
    die 'branch ' . $branchName . ' ' . $remoteBranchName . ' failed.' if $strc;
    $strc = execute($git, ('checkout', $branchName));
    die 'checkout failed.' if $strc;
}

# ---- Windows: Rebuild configure.exe

sub rebuildConfigure
{
    my ($rootDir) = @_;
    print "### Rebuilding configure.exe'\n";
    my $qtbase = File::Spec->catfile($rootDir, 'qtbase');
    my $qmake = File::Spec->catfile($qtbase, 'bin', 'qmake.exe');
    my $configureFolder = File::Spec->catfile($qtbase, 'tools' , 'configure');
    chdir ($configureFolder) or die ('Failed to chdir to "' . $configureFolder . '":' . $!);
    my $makefile = 'Makefile.Release';
    execute('nmake', ('/s', '/f', $makefile, 'clean')) if -f $makefile;
    execute($qmake, ('CONFIG-=debug'));
    execute('nmake', ('/s', '/f', $makefile));
    my $configureExe = File::Spec->catfile($qtbase, 'configure.exe');
    my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size, $atime,$mtime,$ctime,$blksize,$blocks) = stat($configureExe);
    print $configureExe, ' ', $size, ' ', scalar(localtime($mtime)), "\n";
}

# ---- Read a value from the '$HOME/.qt5_tool' configuration file
#      When given a key 'key' for the repository directory '/foo/qt-5',
#      check for the repo-specific value 'key-qt5' and then for the general
#      'key'.

sub readQt5ToolConfig
{
    my ($key) = @_;
    my $repoKey = $key . '-' . $baseDir;
    my $repoValue = readConfigFile($configFile, $repoKey);
    return $repoValue if $repoValue ne '';
    return readConfigFile($configFile, $key);
}

sub readQt5ToolConfigBool
{
   my ($key) = @_;
   my $value = readQt5ToolConfig($key);
   return (length($value) > 0 && ($value eq '1' || $value =~ /true/i)) ? 1 : 0;
}

sub shadowBuildFolder
{
    my $shadowBuildPostfix = readQt5ToolConfig('shadowBuildPostfix');
    return $shadowBuildPostfix ne '' ? $rootDir . $shadowBuildPostfix : '';
}

# ---- Read a list of modules which will be built with -k if the global 'make' fails
sub forceModules()
{
    my $forceModules = readQt5ToolConfig('forceModules');
    return $forceModules ne '' ? split(/ /, $forceModules) : ();
}

# ---- Check for absolute path names.

sub isAbsolute
{
    my ($file) = @_;
    return index($file, ':') == 1 if ($os == $OS_WINDOWS);
    return index($file, '/') == 0;
}

# ---- Determine modules by trying to find <module>/.git/config.
sub determineModules
{
    my ($rootFolder) = @_;
    opendir (DIR, $rootFolder) or die ('Cannot read ' . $rootFolder . $!);
    my @mods = ();
    while (my $e = readdir(DIR)) {
        if ($e ne '.' && $e ne '..') {
            push(@mods, $e) if (-d $e && -f (File::Spec->catfile($e, '.git','config')));
       }
    }
    closedir(DIR);
    die ('Failed to detect modules in ' . $rootFolder . ".\nNeeds to be called from the root directory.") if @mods == 0;
    # Sort & Put a (potentially failing) webkit last.
    my @nonWebKit = sort(grep(!/^qtwebkit$/, @mods));
    my @webKit = grep(/^qtwebkit$/, @mods);
    return (@nonWebKit, @webKit)
}

# ---- Helper to be called before pull. Checks if
#      the module is in a 'no branch' state after init-repository.
#      If so, check out a branch, checking preferredBranches hash.

sub checkoutInitialBranch
{
    my ($mod) = @_;
    # Which branch are we on?
    my $rc = execute($git, ('fetch', '--all'));
    die 'fetch of ' . $mod . ' failed'  if ($rc);
    my @branches = split("\n", `"$git" branch`);
    my @currentBranches = grep(/^\* /, @branches);
    die ('Unable to determine branch of ' . $mod) if @currentBranches != 1;
    my $currentBranch = substr($currentBranches[0], 2);
    #  We have one, no need to act.
    if ($currentBranch ne '(no branch)') {
        print ' branch: ',$currentBranch,"\n";
        return;
    }
    # Switch to suitable branch when none is set initially.
    my $desiredBranch = $preferredBranches{$mod};
    if (defined($desiredBranch) && $desiredBranch eq '') {
        print 'Not changing branch for ',$mod,"\n";
        return;
    }
    # -- Special treatment for webkit: Remove existing invalid branch
    if ($mod eq 'qtwebkit') {
        my $webkitBranch = 'qt-modularization-base';
        execute($git, ('branch', '-D', $webkitBranch));
        $rc = execute($git, 'branch', '--track', $webkitBranch, 'gerrit/' . $webkitBranch);
        die 'tracking branch  ' . $webkitBranch . ' ' . $mod . ' failed' if ($rc);
        $rc = execute($git, ('checkout', $webkitBranch));
        die 'Checkout of ' . $webkitBranch. ' failed'  if ($rc);
        return;
    }
    $desiredBranch = substr($branches[1],2) unless defined $desiredBranch;
    die ('Unable to determine suitable branch for ' . $mod) unless defined $desiredBranch;
    print 'Switching ',$mod, ' from ', $currentBranch,' to ',$desiredBranch,"\n";
    $rc = execute($git, ('checkout', $desiredBranch));
    die 'Checkout of ' . $desiredBranch . ' failed'  if ($rc);
}

# --------------- MAIN: Parse arguments

if (!GetOptions('clean' => \$CLEAN, 'ocumentation' => \$DOC,
     'pull' => \$PULL, 'update' => \$UPDATE, 'reset' => \$RESET, 'diff' => \$DIFF, 's' => \$STATUS,
     'build' => \$BUILD, 'make' => \$MAKE, 'tracking=s' => \$optModuleBranchArgument,
     'gerrit=s' => \$optGerritModule,
     'hook=s' => \$optCommitHook, 'quick-bootstrap'  => \$BOOTSTRAP,
     'w' => \$REBUILD_CONFIGURE)
    || ($CLEAN + $DOC + $PULL + $UPDATE + $BUILD + $MAKE + $RESET + $DIFF + $BOOTSTRAP + $STATUS + $REBUILD_CONFIGURE == 0
        && ! defined $optModuleBranchArgument && !defined $optGerritModule)) {
    print $USAGE;
    exit (1);
}

#   -- Prompt to create config before reading anything for bootstrapping.
if ( $BOOTSTRAP != 0 && ! -f $configFile) {
    print "This appears to be the first use of qt5_tool on this machine.\nCreating ",$configFile, "...,\n";
    my $newNokiaDeveloper = prompt('Nokia developer (y/n)', 'n') =~ /y/i;
    my $newCodeReviewUser = '';
    my $newInitArgumentsDefault = '--no-webkit';
    if ($newNokiaDeveloper) {
        $newCodeReviewUser = prompt('Enter CodeReview user name', $user);
        $newInitArgumentsDefault .= ' --berlin';
    }
    my $newInitArguments = prompt('Enter arguments to init-repository', $newInitArgumentsDefault);
    my $newConfigureArguments = prompt('Enter arguments to configure', '-no-webkit');
    my $configFileHandle = new IO::File('>' . $configFile) or die ('Unable to write to ' . $configFile . ':' . $!);
    print $configFileHandle 'configureArguments=', $newConfigureArguments, "\n" if $newConfigureArguments ne '';
    print $configFileHandle 'initArguments=',$newInitArguments, "\n" if $newInitArguments ne '';
    print $configFileHandle 'codeReviewUser=', $newCodeReviewUser,"\n" if $newCodeReviewUser ne '';
    print $configFileHandle "nokiaDeveloper=true\n" if $newNokiaDeveloper;
    $configFileHandle->close();
    print 'Wrote ',$configFile, "\n";
}

#  --- read config file
my $codeReviewUser = readQt5ToolConfig('codeReviewUser');

# --------------- Bootstrap

if ( $BOOTSTRAP != 0 ) {
    my $nokiaDeveloper = readQt5ToolConfigBool($nokiaDeveloperConfigKey);
    my $repoURL = $nokiaDeveloper  ?
                   ('ssh://' . $codeReviewHost . ':' . $codeReviewPort .'/qt/qt5.git') :
                   $gitoriousURL;
    my $targetFolder = prompt('Enter target folder', 'qt-5');
    my @initOptions;
    push (@initOptions, '-nokia-developer') if $nokiaDeveloper;
    push (@initOptions, '--codereview-username=' . $codeReviewUser) if $codeReviewUser ne '';
    my $initArgumentsFromConfig = readQt5ToolConfig('initArguments');
#   -- Webkit is usually too slow to clone unless something is configured.
    if ($initArgumentsFromConfig ne '') {
        push(@initOptions, split(/ /, $initArgumentsFromConfig));
    } else {
        push(@initOptions, '--no-webkit');
    }
    my $toolsFolder = 'qtrepotools';
    # -- Clone
    my $cloneRc = execute($git, ('clone', $repoURL, $targetFolder));
    die 'clone '. $repoURL  . ' failed.' if $cloneRc;
    chdir($targetFolder) or die ('Failed to chdir to "' . $targetFolder . '":' . $!);
    # -- Run init
    my $initRc = 0;
    if ($os == $OS_WINDOWS) {
        $initRc = execute('perl', 'init-repository', @initOptions);
    } else {
        $initRc = execute('./init-repository', @initOptions);
    }
    die 'init '. $repoURL  . ' failed.' if $initRc;
    exit 0;
}

# --- Change to root: Assume we live in qtrepotools below root.
#     Note: Cwd::realpath is broken in the Symbian-perl-version.
my $prog = $0;
$prog = Cwd::realpath($0) unless isAbsolute($prog);
$rootDir = dirname(dirname(dirname($prog)));
$baseDir = basename($rootDir);
chdir($rootDir) or die ('Failed to chdir to' . $rootDir . '":' . $!);
my $exitCode = 0;

@MODULES = determineModules($rootDir);

print diff($rootDir, \@MODULES) if $DIFF;

# --------------- Reset: Save to a patch in HOME dir indicating date in
#                 file name should there be a diff.
if ( $RESET !=  0 ) {
  print 'Resetting Qt 5 in ',$rootDir,"\n";
  my $changes = diff($rootDir, \@MODULES);
  if ($changes ne '') {
     my $patch = File::Spec->catfile($home, POSIX::strftime('qt5_d%Y%m%d%H%M.patch',localtime));
     my $patchFile = new IO::File('>' . $patch) or die ('Unable to open for writing ' .  $patch . ' :' . $!);
     print $patchFile $changes;
     $patchFile->close();
     print 'Saved ', $patch, "\n";
  }
  my @resetArgs = ('reset','--hard');
  runGit(\@resetArgs, 1);
}

# --------------- Status.
if ( $STATUS !=  0 ) {
    my @branchArgs = ('branch', '-v');
    runGit(\@branchArgs, 1);
    my @statusArgs = ('status');
    runGit(\@statusArgs, 1);
}

# --------------- Switch to branch

if (defined $optModuleBranchArgument) {
#   -- Split arguments of form module[:origin/refactor]
    my ($branchName, $remoteBranchName ) = ('staging','staging/master');
    my $bColon = index($optModuleBranchArgument, ':');
    if ($bColon > 0) {
        $remoteBranchName = substr($optModuleBranchArgument, $bColon + 1);
        my $bSlash = index($remoteBranchName, '/');
        die ('Invalid remote branch name' . $remoteBranchName) if ($bSlash < 1);
        $branchName = substr($remoteBranchName, $bSlash + 1);
        $optModuleBranchArgument = substr($optModuleBranchArgument, 0, $bColon);
    }
    chdir($optModuleBranchArgument) or die ('Failed to chdir from' . $rootDir . ' to "' . $optModuleBranchArgument . '":' . $!);
    initTrackingBranch($branchName, $remoteBranchName);
#   -- Copy/Link the commit hook: Try to autodetect standard setup.
    if (!defined $optCommitHook && $os != $OS_WINDOWS) {
       my $hook = $ENV{"HOME"} . '/dev/devtools/shell/git_post_commit_hook';
       $optCommitHook = $hook if -f $hook;
    }
#   -- Link or copy the hook according to platform.
    if (defined $optCommitHook) {
        my $target =File::Spec->catfile('.git', 'hooks' ,'post-commit');
        if (! -e $target) {
            print 'Setting up commit hook: ', $optCommitHook, ' ', $target,"\n";
            if ($os == $OS_WINDOWS) {
               execute('xcopy.exe', $optCommitHook, $target);
            } else {
                execute('ln', '-s', $optCommitHook, $target);
            }
        }
    }
    chdir($rootDir);
}

# --------------- Init gerrit

if (defined $optGerritModule) {
    my $scp = which('scp');
    $scp = msysGitUtility($git, 'scp') unless defined $scp || $os != $OS_WINDOWS;
    die ('Unable to locate scp.') unless defined $scp;
    die ('This option requires a codereview-user name') if $codeReviewUser eq '';
    chdir($optGerritModule) or die ('Failed to chdir from' . $rootDir . ' to "' . $optGerritModule);
    my $remoteRepo = $codeReviewUser . '@' . $codeReviewHost . ':qt/' . $optGerritModule;
    print 'Configuring ', $remoteRepo, "\n";
    my $grc = execute($git, ('config', 'remote.origin.url',  $remoteRepo));
    die 'Config failed'  if ($grc);
    print 'Initializing hooks', "\n";
    $grc = execute($scp, ('-p',  $codeReviewUser . '@' . $codeReviewHost . ':hooks/commit-msg', '.git/hooks'));
    die 'Copying of commit hook failed'  if ($grc);
    print 'Fetch all...', "\n";
    $grc = execute($git, ('fetch', '--all'));
    chdir($rootDir);
}

# --------------- Clean if desired

if ( $CLEAN !=  0 ) {
  print 'Cleaning Qt 5 in ',$rootDir,"\n";
  my @cleanArgs = ('clean','-dxf');
  execute($git, @cleanArgs);
  runGit(\@cleanArgs);
}

# ---- Pull: Switch to branch unless there is one (check preferred
#      branch hash, default to branch n+1, which is mostly master).

if ( $PULL !=  0 ) {
    print 'Pulling Qt 5 in ',$rootDir,"\n";
    my $prc = execute($git, ('pull'));
    die 'Pull failed'  if ($prc);
    foreach my $MOD (@MODULES) {
        print 'Examining: ', $MOD, ' url: ',readGitConfig($MOD, 'url'), ' ';
        chdir($MOD) or die ('Failed to chdir from' . $rootDir . ' to "' . $MOD . '":' . $!);
        checkoutInitialBranch($MOD);
        print 'Pulling ', $MOD, "\n";
        $prc = execute($git, ('pull'));
        die 'Pull ' . $MOD . ' failed'  if ($prc);
        chdir($rootDir);
   } # foreach
} # pull

# --------------- Rebuild configure.exe
if ( $REBUILD_CONFIGURE !=  0 ) {
    rebuildConfigure($rootDir);
}

# ---- Update

if ( $UPDATE !=  0 ) {
    print 'Updating Qt 5 in ',$rootDir,"\n";
    my $urc = execute($git, ('pull'));
    die 'pull failed'  if ($urc);
    $urc = execute($git, ('submodule', 'update'));
    die 'update failed'  if ($urc);
}

# ---- Configure and build

if ( $BUILD !=  0 ) {
    print 'Building Qt 5 in ',$rootDir,"\n";
    winRemoveGitFromPath() if $minGW;
    my @configureArguments = ('-prefix', File::Spec->catfile($rootDir, 'qtbase'), '-confirm-license');
#   -- Remove later.
    push (@configureArguments, '-no-qt3support') if $os == $OS_WINDOWS;
    push (@configureArguments, readQt5ToolConfigBool($nokiaDeveloperConfigKey) ? '-nokia-developer' : '-opensource');
    push (@configureArguments, '-nomake', 'tests', '-nomake', 'demos', '-nomake examples');
#   -- detect X11
    push (@configureArguments, '-xcb') if defined $ENV{'DISPLAY'};
    my $configureArgumentsFromConfig = readQt5ToolConfig('configureArguments');
    push(@configureArguments, split(/ /, $configureArgumentsFromConfig)) unless $configureArgumentsFromConfig eq '';
#   --- Shadow builds: Remove and re-create directory
    my $shadowBuildDir = shadowBuildFolder();
    if ($shadowBuildDir ne '') {
        print 'Shadow build: "', $shadowBuildDir,"\"\n";
        if (-d $shadowBuildDir) {
            File::Path::rmtree($shadowBuildDir) or die ('Unable to remove ' . $shadowBuildDir . ' :' . $!);
        }
        mkdir($shadowBuildDir) or die  ('Unable to create ' . $shadowBuildDir . ' :' . $!);
        chdir($shadowBuildDir) or die  ('Unable to chdir ' . $shadowBuildDir . ' :' . $!);
    }
#   ---- Configure and build
    my $brc = execute(File::Spec->catfile($rootDir, 'configure'), @configureArguments);
    die 'Configure failed'  if ($brc);
#   --- Workaround: The module .pri files are currently (as of 30.9.2011) not copied to their
#       target location on Windows.
    if ($os == $OS_WINDOWS) {
        my $targetProfileFolder = File::Spec->catfile($rootDir, 'qtbase', 'mkspecs', 'modules');
        if (! -f File::Spec->catfile($targetProfileFolder, 'qt_core.pri')) {
            foreach my $module (@MODULES) {
                my $sourceProfilePattern = File::Spec->catfile($rootDir, $module, 'module-paths', 'modules' , '*.pri');
                foreach my $sourceProfile (glob($sourceProfilePattern)) {
                    print 'Workaround: Copying ', $sourceProfile, ' to ',$targetProfileFolder,"\n";
                    File::Copy::copy($sourceProfile, $targetProfileFolder) or die ('Copy error '. $!);
                }
            }
        }
   }
}

if ( $BUILD + $MAKE !=  0) {
    if ($BUILD == 0) { # Did not go through configure, cd
        my $makeShadowBuildDir = shadowBuildFolder();
        if ($makeShadowBuildDir ne '') {
            print 'Shadow build: "', $makeShadowBuildDir,"\"\n";
            chdir($makeShadowBuildDir) or die  ('Unable to chdir ' . $makeShadowBuildDir . ' :' . $!);
        }
    }
#   Run a global make. If that fails, check if a list of 'force modules' is configured and build them with -k
    my $makeRc = execute($make, @makeArgs);
    if ($makeRc) {
        $exitCode = 1;
        my @forcedModules = forceModules();
        die ($make . ' failed')  if @forcedModules == 0;
        warn ('######' . $make . ' failed, resorting to forcibly building ' . join(',', @forcedModules))  if ($makeRc);
        push(@makeArgs, $makeForceArg);
        foreach my $MOD (@forcedModules) {
            chdir($MOD) or die ('Failed to chdir from' . $rootDir . ' to "' . $MOD . '":' . $!);
            my $subMakeRc = execute($make, @makeArgs);
            warn ('######' . $make . ' failed in ' . $MOD . '.')  if ($subMakeRc);
            chdir($rootDir);
        }
    }
}

# ---- Untested: Build documentation.

if ($DOC !=  0 ) {
   print 'Documenting Qt 5 in ',$rootDir,"\n";
   my $drc = execute($make, (@makeArgs,'docs'));
   die ($make . ' docs failed')  if ($drc);
}

exit($exitCode);
