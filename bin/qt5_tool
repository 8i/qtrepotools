#!/usr/bin/perl -w
####################################################################################################
#
# Helper script for Qt 5
#
# Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
# Contact: http://www.qt-project.org/
#
####################################################################################################

############################################################################################
#
# Convenience script working with a Qt 5 repository.
#
# Feel free to add useful options!
#
# The intention is that this works with the old Perl used for Symbian as well:
# - Variables should not shadow others.
# - Some functions are just broken  (abs_path()),etc.
############################################################################################

use strict;

use Getopt::Long;
use File::Basename;
use Cwd;
use File::Spec;
use File::Copy;
use POSIX;
use IO::File;
use File::Path;

my $CLEAN=0;
my $DOC=0;
my $PULL=0;
my $BUILD=0;
my $MAKE=0;
my $RESET=0;
my $DIFF=0;
my $BOOTSTRAP=0;
my $STATUS=0;
my $UPDATE=0;
my $TEST=0;
my $REBUILD_CONFIGURE=0;
my $optModuleBranchArgument;
my $optGerritModule;
my $optCommitHook;
my $gitoriousURL = 'git://gitorious.org/qt/qt5.git';
my $codeReviewHost = 'codereview.qt-project.org';
my $codeReviewPort = 29418;
my $configFile = '.qt5_tool';

my $USAGE=<<EOF;
Usage: qt5_tool [OPTIONS]

Utility script for working with Qt 5 modules.

Feel free to extend!

Options:
  -d  Diff (over all modules, relative to root)
  -s  Status
  -r  Reset hard
  -c  Clean
  -u  Update
  -p  Pull (for development only)
  -b  Build (configure + build)
  -m  Make
  -o  [D]ocumentation
  -t  Test: Builds and runs tests located in tests/auto for each module,
      creates log file(s) in that directory as well as a summary log  file.
  -q  Quick bootstrap a new checkout under current folder.
  -w  Windows: Rebuild configure.exe (requires MSVC setup)
  -g <module> Set up gerrit for the module.
  -a <module> Set up a tracking branch for the module. By default, this is
              staging/master. It is possible the specify the branch by appending
              :remote-branch to the module parameter, for example:
              qtbase:origin/refactor
  -h <hook>   Path to commit hook for -s.

Example use cases:
  qt5_tool -c -u -b     Clean, update and build for nightly builds
  qt5_tool -d           Generate modules diff relative to root directory
  qt5_tool -r           Reset --hard of repo.

qt_tool can be configured by creating a configuration file \$HOME/$configFile in
the format key=value. It is possible to use repository-specific values by
adding a key postfixed by a dash and the repository folder base name.
Use 'true', '1' for Boolean keys.
Supported keys:

nokiaDeveloper:     Nokia Developer mode (Boolean)
initArguments:      Arguments to init-repository for -q. Example:
                    [--berlin-|--brisbane-|--]nokia-developer
codeReviewUser:     User name for code review (Gerrit)
configureArguments: Arguments to configure
shadowBuildPostfix: Postfix to use for shadow build directory.
forceModules:       A list of modules (like "qtbase qtscript") that will be
                    built using 'make -k' if the global 'make' fails.
Example:
shadowBuildPostfix=-build
shadowBuildPostfix-qt-5special=-special-build

specifies that for a checkout in '/home/user/qt-5', shadow builds are to be
done in '/home/user/qt-5-build'. It is overridden by a value for the checkout
'/home/user/qt-5special', which would result in '/home/user/qt-5-special-build'
EOF

my %preferredBranches = (
#    'qtwebkit' , 'qt-modularization-base'
);

# --------------- Detect OS

my ($OS_LINUX, $OS_WINDOWS, $OS_MAC)  = (0, 1, 2);
my $os = $OS_LINUX;
if (index($^O, 'MSWin') >= 0) {
    $os = $OS_WINDOWS;
} elsif (index($^O, 'darwin') >= 0) {
   $os = $OS_MAC;
}

# -- Convenience for path search.
#    There is File::Which, but not by default installed on Linux.

sub which
{
    my ($needle) = @_;
    my $sep = $os == $OS_WINDOWS ? ';' : ':';
    my @needles = ($needle);
    push(@needles, $needle . '.exe', $needle . '.bat', $needle . '.cmd') if $os == $OS_WINDOWS;
    foreach my $path (split(/$sep/, $ENV{'PATH'})) {
        foreach my $n (@needles) {
            my $binary = File::Spec->catfile($path, $n);
            return $binary if (-f $binary);
        }
    }
    return undef;
}

# -- Locate an utility (grep, scp, etc) in MSYS git. This is specifically
#    for the setup case in which only git.cmd and not the utilities are in
#    the path. We then look at the git.cmd and return ..\bin\<utility>.exe.
sub msysGitUtility
{
#   -- Look for 'git.cmd' and cd ..\bin
    my ($git, $utility) = @_;
    if ($git =~ /.cmd$/i) {
        my $msysGitBinFolder = File::Spec->catfile(dirname(dirname($git)), 'bin');
        return File::Spec->catfile($msysGitBinFolder, $utility . '.exe');
    }
    return $utility;
}

my $qmakeSpec = $ENV{'QMAKESPEC'};
my $minGW = $os == $OS_WINDOWS && defined($qmakeSpec) && index($qmakeSpec,'g++') > 0;
my $make = 'make';
$make = $minGW ?  'mingw32-make' : 'nmake' if ($os == $OS_WINDOWS);

my @makeArgs = $os == $OS_WINDOWS && !$minGW ? ('/s') : ('-s');
$ENV{'CL'} = '/MP' if $os == $OS_WINDOWS; # Switch cl compiler to multicore
my $git = which('git'); # TODO: Mac, Windows special cases?
die ('Unable to locate git') unless defined $git;

my $makeForceArg = $os == $OS_WINDOWS && !$minGW ? '/k' : '-k';

my $rootDir = '';
my $baseDir = '';
my $home = $os == $OS_WINDOWS ? ($ENV{'HOMEDRIVE'} . $ENV{'HOMEPATH'}) : $ENV{'HOME'};

# -- Set a HOME variable on Windows such that scp. etc. feel at home (locating .ssh).
$ENV{'HOME'} = $home if ($os == $OS_WINDOWS && not defined $ENV{'HOME'});

my $user = $os == $OS_WINDOWS ? $ENV{'USERNAME'} : $ENV{'USER'};
$configFile = File::Spec->catfile($home, $configFile);

my @MODULES = ();

my ($developerBuildConfigKey, $nokiaDeveloperConfigKey) = ('developerBuild', 'nokiaDeveloper');

# --- Execute a command and print to log.
sub execute
{
    my @args = @_;
    print '### [',basename(getcwd()),'] ', join(' ', @args),"\n";
    return system(@args);
}

sub executeCheck
{
    my @args = @_;
    my $rc = execute(@args);
    die ($args[0] . ' failed ' . $rc . ':' . $!) if $rc != 0;
}

# --- Prompt for input with a default

sub prompt
{
    my ($promptText, $defaultValue) = @_;
    print $promptText,' [', $defaultValue, ']:';
    my $userInput = <STDIN>;
    chomp ($userInput);
    return $userInput eq '' ? $defaultValue : $userInput;
}

# --- Fix a diff line from a submodule such that it can be applied to
#     the root Qt 5 directory, that is:
#     '--- a/foo...' -> '--- a/<module>/foo...'

sub fixDiff
{
   my ($line, $module) = @_;
   if (index($line, '--- a/') == 0 || index($line, '+++ b/') == 0) {
       return substr($line, 0, 6) . $module . '/' . substr($line, 6);
   }
   if (index($line, 'diff --git ') == 0) {
       $line =~ s| a/| a/$module/|;
       $line =~ s| b/| b/$module/|;
   }
   return $line;
}

# --- Determine a suitable log file name for test log files.

sub formatTestLogBaseName
{
    my ($number, $module) = @_;
    my $result = 'test';
    $result .= '_win' if $os == $OS_WINDOWS;
    $result .= '_unix' if $os == $OS_LINUX;
    $result .= '_mac' if $os == $OS_MAC;
    if (defined $module) {
        $result .= '_';
        $result .=  index($module, 'qt') == 0 ? substr($module, 2) : $module;
    }
    $result .= '_' . strftime('%y%m%d', localtime());
    $result .= '_' . $number if $number > 0;
    return $result;
}

# ---- Generate a diff from all submodules such that it can be applied to
#      the root Qt 5 directory.

sub diff
{
    my $totalDiff = '';
    my ($rootDir,$modArrayRef) = @_;
    foreach my $MOD (@$modArrayRef) {
     chdir($MOD) or die ('Failed to chdir from' . $rootDir . ' to "' . $MOD . '":' . $!);
     my $diffOutput = `"$git" diff`;
     foreach my $line (split(/\n/, $diffOutput)) {
         chomp($line);
         $totalDiff .= fixDiff($line, $MOD);
         $totalDiff .= "\n";
     }
     chdir($rootDir);
  }
  return $totalDiff;
}

# ---- Run git in root and module folders.
#      Do not use 'git submodules foreach' to be able to work on partially corrupt repositories

sub runGit
{
    my ($argListRef, $keepGoing) = @_;
    my $argString = join(' ', @$argListRef);
    print 'Running ', $argString, "\n";
    my $runRC = execute($git, @$argListRef);
    if ($runRC) {
       if ($keepGoing) {
          warn($argString . ' failed in root.');
       } else {
          die ($argString . ' failed in root.');
       }
    }
    foreach my $MOD (@MODULES) {
        chdir($MOD) or die ('Failed to chdir from' . $rootDir . ' to "' . $MOD . '":' . $!);
        my $modRunRC = execute($git, @$argListRef);
        if ($modRunRC) {
            if ($keepGoing) {
                warn($argString . ' failed in ' . $MOD);
            } else {
               die ($argString . ' failed in ' . $MOD);
            }
           $runRC = 1;
        }
        chdir($rootDir);
    }
    return $runRC;
}

# ---- Read a value from a configuration file of the form key=value.

sub readConfigFile
{
    my ($fileName, $key) = @_;

    my $configLine = '';
    my $configFile = new IO::File('<' . $fileName) or return $configLine;
    while (my $line = <$configFile>) {
        chomp($line);
        if ($line =~ /^\s*$key\s*=\s*(.*)$/) {
           $configLine .= $1;
           last;
        }
    }
    $configFile->close();
    return $configLine;
}

# ---- Read a value from a git config line.

sub readGitConfig
{
    my ($module, $key) = @_;
    return readConfigFile(File::Spec->catfile($rootDir, $module, '.git', 'config'), $key);
}

# ---- MinGW: Remove git from path (prevent sh.exe from throwing off mingw32-make).

sub winRemoveGitFromPath
{
    my @path = split(/;/, $ENV{'PATH'});
    my @cleanPath = grep(!/git/, @path);
    if (@path != @cleanPath) {
        print 'Removing git from path...';
        $ENV{'PATH'} = join(';', @cleanPath);
    }
}

# ---- Set up a tracking branch
sub initTrackingBranch
{
    my ($branchName, $remoteBranchName) = @_;
    my $strc = execute($git, ('fetch', '--all'));
    die 'fetch failed.' if $strc;
    print 'Switching to ', $branchName, ' from ', $remoteBranchName, "\n";
    $strc = execute($git, ('branch', '--track', $branchName, $remoteBranchName));
    die 'branch ' . $branchName . ' ' . $remoteBranchName . ' failed.' if $strc;
    $strc = execute($git, ('checkout', $branchName));
    die 'checkout failed.' if $strc;
}

# ----- Create ls -l like listing for a file name
sub ls
{
    my ($fileName) = @_;
    my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size, $atime,$mtime,$ctime,$blksize,$blocks) = stat($fileName);
    return $fileName . ' not found' unless defined $dev;
    return $fileName . ' ' . $size . ' ' . scalar(localtime($mtime));
}

# ---- Windows: Rebuild configure.exe

sub rebuildConfigure
{
    my ($rootDir) = @_;
    print "### Rebuilding configure.exe'\n";
    my $qtbase = File::Spec->catfile($rootDir, 'qtbase');
    my $qmake = File::Spec->catfile($qtbase, 'bin', 'qmake.exe');
    my $configureFolder = File::Spec->catfile($qtbase, 'tools' , 'configure');
    chdir ($configureFolder) or die ('Failed to chdir to "' . $configureFolder . '":' . $!);
    my $makefile = 'Makefile.Release';
    execute('nmake', ('/s', '/f', $makefile, 'clean')) if -f $makefile;
    execute($qmake, ('CONFIG-=debug'));
    executeCheck('nmake', ('/s', '/f', $makefile));
    my $configureExe = File::Spec->catfile($qtbase, 'configure.exe');
    print "\n",ls($configureExe), "\n";
}

# ---- Read a value from the '$HOME/.qt5_tool' configuration file
#      When given a key 'key' for the repository directory '/foo/qt-5',
#      check for the repo-specific value 'key-qt5' and then for the general
#      'key'.

sub readQt5ToolConfig
{
    my ($key) = @_;
    my $repoKey = $key . '-' . $baseDir;
    my $repoValue = readConfigFile($configFile, $repoKey);
    return $repoValue if $repoValue ne '';
    return readConfigFile($configFile, $key);
}

sub readQt5ToolConfigBool
{
   my ($key) = @_;
   my $value = readQt5ToolConfig($key);
   return (length($value) > 0 && ($value eq '1' || $value =~ /true/i)) ? 1 : 0;
}

sub shadowBuildFolder
{
    my $shadowBuildPostfix = readQt5ToolConfig('shadowBuildPostfix');
    return $shadowBuildPostfix ne '' ? $rootDir . $shadowBuildPostfix : '';
}

# ---- Read a list of modules which will be built with -k if the global 'make' fails
sub forceModules()
{
    my $forceModules = readQt5ToolConfig('forceModules');
    return $forceModules ne '' ? split(/ /, $forceModules) : ();
}

# ---- Check for absolute path names.

sub isAbsolute
{
    my ($file) = @_;
    return index($file, ':') == 1 if ($os == $OS_WINDOWS);
    return index($file, '/') == 0;
}

# ---- Determine modules by trying to find <module>/.git/config.
sub determineModules
{
    my ($rootFolder) = @_;
    opendir (DIR, $rootFolder) or die ('Cannot read ' . $rootFolder . $!);
    my @mods = ();
    while (my $e = readdir(DIR)) {
        if ($e ne '.' && $e ne '..' && -d $e && $e ne 'qtquick3d') {
            my $gitFolder = File::Spec->catfile($e, '.git');
            push(@mods, $e) if -e $gitFolder;
       }
    }
    closedir(DIR);
    die ('Failed to detect modules in ' . $rootFolder . ".\nNeeds to be called from the root directory.") if @mods == 0;
    # Sort & Put a (potentially failing) webkit last.
    my @nonWebKit = sort(grep(!/^qtwebkit$/, @mods));
    my @webKit = grep(/^qtwebkit$/, @mods);
    return (@nonWebKit, @webKit)
}

# ---- Helper to be called before pull. Checks if
#      the module is in a 'no branch' state after init-repository.
#      If so, check out a branch, checking preferredBranches hash.

sub checkoutInitialBranch
{
    my ($mod) = @_;
    # Which branch are we on?
    my $rc = execute($git, ('fetch', '--all'));
    die 'fetch of ' . $mod . ' failed'  if ($rc);
    my @branches = split("\n", `"$git" branch`);
    my @currentBranches = grep(/^\* /, @branches);
    die ('Unable to determine branch of ' . $mod) if @currentBranches != 1;
    my $currentBranch = substr($currentBranches[0], 2);
    #  We have one, no need to act.
    if ($currentBranch ne '(no branch)') {
        print ' branch: ',$currentBranch,"\n";
        return;
    }
    # Switch to suitable branch when none is set initially.
    my $desiredBranch = $preferredBranches{$mod};
    if (defined($desiredBranch) && $desiredBranch eq '') {
        print 'Not changing branch for ',$mod,"\n";
        return;
    }
    # -- Special treatment for webkit: Remove existing invalid branch
    if ($mod eq 'qtwebkit') {
        my $webkitBranch = 'qt-modularization-base';
        execute($git, ('branch', '-D', $webkitBranch));
        $rc = execute($git, 'branch', '--track', $webkitBranch, 'gerrit/' . $webkitBranch);
        die 'tracking branch  ' . $webkitBranch . ' ' . $mod . ' failed' if ($rc);
        $rc = execute($git, ('checkout', $webkitBranch));
        die 'Checkout of ' . $webkitBranch. ' failed'  if ($rc);
        return;
    }
    $desiredBranch = substr($branches[1],2) unless defined $desiredBranch;
    die ('Unable to determine suitable branch for ' . $mod) unless defined $desiredBranch;
    print 'Switching ',$mod, ' from ', $currentBranch,' to ',$desiredBranch,"\n";
    $rc = execute($git, ('checkout', $desiredBranch));
    die 'Checkout of ' . $desiredBranch . ' failed'  if ($rc);
}

# --------------- MAIN: Parse arguments

if (!GetOptions('clean' => \$CLEAN, 'ocumentation' => \$DOC,
     'pull' => \$PULL, 'update' => \$UPDATE, 'reset' => \$RESET, 'diff' => \$DIFF, 's' => \$STATUS,
     'build' => \$BUILD, 'make' => \$MAKE, 'test' => \$TEST,
     'acking=s' => \$optModuleBranchArgument, 'gerrit=s' => \$optGerritModule,
     'hook=s' => \$optCommitHook, 'quick-bootstrap'  => \$BOOTSTRAP,
     'w' => \$REBUILD_CONFIGURE)
    || ($CLEAN + $DOC + $PULL + $UPDATE + $BUILD + $MAKE + $RESET + $DIFF + $BOOTSTRAP + $STATUS
        + $REBUILD_CONFIGURE + $TEST == 0
        && ! defined $optModuleBranchArgument && !defined $optGerritModule)) {
    print $USAGE;
    exit (1);
}

sub defaultConfigureArguments
{
    my ($developerBuild) = @_;
    my $result = '-confirm-license';
    $result .= ' -developer-build' if ($developerBuild);
    $result .= ' -opensource -debug';
#   On Mac, -debug requires -no-framework (or use -debug-and-release)?
    $result .= ' -no-framework' if  $os == $OS_MAC;
    $result .= ' -xcb' if $os == $OS_LINUX && defined $ENV{'DISPLAY'};
    $result .= ' -nomake tests -nomake examples';
    return $result;
}

#   -- Prompt to create config before reading anything for bootstrapping.
if ( $BOOTSTRAP != 0 && ! -f $configFile) {
    print "This appears to be the first use of qt5_tool on this machine.\nCreating configuration file '",$configFile, "'...,\n";
    my $newDeveloperBuild = prompt('Developer build (y/n)', 'y') =~ /y/i;
    my $newNokiaDeveloper = prompt('Nokia developer (y/n)', 'n') =~ /y/i;
    my $newCodeReviewUser = '';
    my $newInitArgumentsDefault = '--no-webkit';
    $newCodeReviewUser = prompt('Enter CodeReview user name', $user) if ($newDeveloperBuild || $newNokiaDeveloper);
    $newInitArgumentsDefault .= ' --berlin'  if $newNokiaDeveloper;
    my $newInitArguments = prompt('Enter arguments to init-repository', $newInitArgumentsDefault);
    my $newConfigureArguments = prompt('Enter arguments to configure', defaultConfigureArguments($newDeveloperBuild));
    my $configFileHandle = new IO::File('>' . $configFile) or die ('Unable to write to ' . $configFile . ':' . $!);
    print $configFileHandle 'configureArguments=', $newConfigureArguments, "\n" if $newConfigureArguments ne '';
    print $configFileHandle 'initArguments=',$newInitArguments, "\n" if $newInitArguments ne '';
    print $configFileHandle 'codeReviewUser=', $newCodeReviewUser,"\n" if $newCodeReviewUser ne '';
    print $configFileHandle $developerBuildConfigKey, "=true\n" if $newNokiaDeveloper;
    print $configFileHandle $nokiaDeveloperConfigKey, "=true\n" if $newDeveloperBuild;
    $configFileHandle->close();
    print 'Wrote ',$configFile, "\n";
}

#  --- read config file
my $codeReviewUser = readQt5ToolConfig('codeReviewUser');

# --------------- Bootstrap

if ( $BOOTSTRAP != 0 ) {
    my $nokiaDeveloper = readQt5ToolConfigBool($nokiaDeveloperConfigKey);
    my $developerBuild = readQt5ToolConfigBool($developerBuildConfigKey);
    my $repoURL = $nokiaDeveloper  ?
                   ('ssh://' . $codeReviewHost . ':' . $codeReviewPort .'/qt/qt5.git') :
                   $gitoriousURL;
    my $targetFolder = prompt('Enter target folder', 'qt-5');
    my @initOptions;
    push (@initOptions, '-nokia-developer') if $nokiaDeveloper;
    push (@initOptions, '--codereview-username=' . $codeReviewUser) if $codeReviewUser ne '';
    my $initArgumentsFromConfig = readQt5ToolConfig('initArguments');
#   -- Webkit is usually too slow to clone unless something is configured.
    if ($initArgumentsFromConfig ne '') {
        push(@initOptions, split(/ /, $initArgumentsFromConfig));
    } else {
        push(@initOptions, '--no-webkit');
    }
    my $toolsFolder = 'qtrepotools';
    # -- Clone
    my $cloneRc = execute($git, ('clone', $repoURL, $targetFolder));
    die 'clone '. $repoURL  . ' failed.' if $cloneRc;
    chdir($targetFolder) or die ('Failed to chdir to "' . $targetFolder . '":' . $!);
    # -- Run init
    my $initRc = 0;
    if ($os == $OS_WINDOWS) {
        $initRc = execute('perl', 'init-repository', @initOptions);
    } else {
        $initRc = execute('./init-repository', @initOptions);
    }
    die 'init '. $repoURL  . ' failed.' if $initRc;
    exit 0;
}

# --- Change to root: Assume we live in qtrepotools below root.
#     Note: Cwd::realpath is broken in the Symbian-perl-version.
my $prog = $0;
$prog = Cwd::realpath($0) unless isAbsolute($prog);
$rootDir = dirname(dirname(dirname($prog)));
$baseDir = basename($rootDir);
chdir($rootDir) or die ('Failed to chdir to' . $rootDir . '":' . $!);
my $exitCode = 0;

@MODULES = determineModules($rootDir);

print diff($rootDir, \@MODULES) if $DIFF;

# --------------- Reset: Save to a patch in HOME dir indicating date in
#                 file name should there be a diff.
if ( $RESET !=  0 ) {
  print 'Resetting Qt 5 in ',$rootDir,"\n";
  my $changes = diff($rootDir, \@MODULES);
  if ($changes ne '') {
     my $patch = File::Spec->catfile($home, POSIX::strftime('qt5_d%Y%m%d%H%M.patch',localtime));
     my $patchFile = new IO::File('>' . $patch) or die ('Unable to open for writing ' .  $patch . ' :' . $!);
     print $patchFile $changes;
     $patchFile->close();
     print 'Saved ', $patch, "\n";
  }
  my @resetArgs = ('reset','--hard');
  runGit(\@resetArgs, 1);
}

# --------------- Status.
if ( $STATUS !=  0 ) {
    my @branchArgs = ('branch', '-v');
    runGit(\@branchArgs, 1);
    my @statusArgs = ('status');
    runGit(\@statusArgs, 1);
}

#   --------------- TEST: Run auto-tests in relevant modules
#   and create a summary log, and optionally, if the converter can be
#   found, a tasks file for Qt Creator..

if ( $TEST !=  0 ) {
    my %testPaths;
    my $testRelativePath = File::Spec->catfile('tests', 'auto');
    my $catCommand = $os == $OS_WINDOWS ? 'type' : 'cat';
#   ---  Find relevant modules.
    foreach my $MOD (@MODULES) {
        my $excluded = ($MOD eq 'qtactiveqt'   && $os != $OS_WINDOWS)
                       || ($MOD eq 'qtjsondb'  && $os == $OS_WINDOWS)
                       || ($MOD eq 'qtwayland' && $os == $OS_WINDOWS);
        if (!$excluded) {
            my $testPath = File::Spec->catfile($MOD, $testRelativePath);
            $testPaths{$MOD} = $testPath if -d $testPath;
        }
    }
#   -- Locate 'test2tasks.pl'. This is a script located in the Qt Creator repository
#      that converts test output into task files that can be loaded into Qt  Creator's
#      'Build issues' pane.
    my $test2tasks = which('test2tasks.pl');
#   -- Initialize logging, find a unique log file name.
    my $testLogUniqueNumber = 0;
    my ($summaryLogFile, $summaryTasksFile);
    for ( ; ; $testLogUniqueNumber++) {
        my $testLogBaseName = formatTestLogBaseName($testLogUniqueNumber);
        $summaryLogFile = File::Spec->catfile($rootDir, $testLogBaseName . '.log');
        $summaryTasksFile = File::Spec->catfile($rootDir, $testLogBaseName . '.tasks');
        last unless -f $summaryLogFile || -f $summaryTasksFile;
    }
    if (-e $summaryTasksFile) {
        unlink($summaryTasksFile) or die ('Unable to delete existing tasks file ' . $summaryTasksFile . ' ' . $!);
    }
    print '### Testing ', scalar(keys(%testPaths)), ' modules: ', join(', ', keys(%testPaths)), "\n### Logging to: ",
          $summaryLogFile, "\n";
#   -- Build the tests, qmake, make
    my @buildFailures;
    my $tn = 0;
    foreach my $testPath (values(%testPaths)) {
        chdir($testPath) || die ('Failed to chdir from' . $rootDir . ' to "' . $testPath);
        print '### Building #', ++$tn, ' of ', scalar(keys(%testPaths)), ' ', $testPath, "\n";
        my $rc = execute('qmake');
        die ('qmake failed') unless $rc == 0;
        $rc = execute($make, @makeArgs);
        if ($rc != 0) {
            print '### Warning: Build failed in ', $testPath, "\n";
            push (@buildFailures, $testPath);
        }
        chdir($rootDir);
    }
#   -- Run the test: 'make check'. Explicitly set 'Keep' on Windows as flags are not propagated.
    $tn = 0;
    $ENV{'MAKEFLAGS'} = 'K' if  $make eq 'nmake';
    foreach my $module (keys(%testPaths)) {
        my $testPath = $testPaths{$module};
        ++$tn;
        if (grep (/$testPath/, @buildFailures)) {
            print '### Skipping ', $testPath, "\n";
            next;
        }
        chdir($testPath) || die ('Failed to chdir from' . $rootDir . ' to "' . $testPath);
        print '### Running #', ++$tn, ' of ', scalar(keys(%testPaths)), ' ', $testPath, "\n";
        my $moduleLogBaseName = formatTestLogBaseName($testLogUniqueNumber, $module);
        my $moduleLogFile = File::Spec->catfile(getcwd(), $moduleLogBaseName . '.log');
        my $moduleTasksFile = File::Spec->catfile(getcwd(),  $moduleLogBaseName . '.tasks');
        my $cmd = $make . ' ' . join(' ', @makeArgs) . ' ' . $makeForceArg . ' check > ' .  $moduleLogFile;
        print '### Running: ', $cmd, "\n";
        system($cmd);
#       -- concat log file.
        $cmd = $catCommand . ' ' . $moduleLogFile . ' >> ' . $summaryLogFile;
        print '### Running: ', $cmd, "\n";
        system($cmd);
#       --- Create a tasks file for Qt Creator
        if (defined $test2tasks) {
#           -- Local file with relative paths
                $cmd = $test2tasks . ' < ' . $moduleLogFile . ' > ' . $moduleTasksFile;
            print '### Running: ', $cmd, "\n";
                   system($cmd);
#           -- Append to summary file with path relative to its location
            $cmd = $test2tasks . ' -r ' . $testPath . ' < ' . $moduleLogFile . ' >> ' . $summaryTasksFile;
            print '### Running: ', $cmd, "\n";
            system($cmd);
        }
        chdir($rootDir);
    }
    my $report = "\n### Testing done:\n";
    $report .= '- Build failures: ' . join(', ', @buildFailures) . "\n" if (scalar(@buildFailures));
    $report .= '- ' . ls($summaryLogFile) . "\n";
    $report .= '- ' . ls($summaryTasksFile) . "\n" if defined $test2tasks;
    print $report;
}

# --------------- Switch to branch

if (defined $optModuleBranchArgument) {
#   -- Split arguments of form module[:origin/refactor]
    my ($branchName, $remoteBranchName ) = ('staging','staging/master');
    my $bColon = index($optModuleBranchArgument, ':');
    if ($bColon > 0) {
        $remoteBranchName = substr($optModuleBranchArgument, $bColon + 1);
        my $bSlash = index($remoteBranchName, '/');
        die ('Invalid remote branch name' . $remoteBranchName) if ($bSlash < 1);
        $branchName = substr($remoteBranchName, $bSlash + 1);
        $optModuleBranchArgument = substr($optModuleBranchArgument, 0, $bColon);
    }
    chdir($optModuleBranchArgument) or die ('Failed to chdir from' . $rootDir . ' to "' . $optModuleBranchArgument . '":' . $!);
    initTrackingBranch($branchName, $remoteBranchName);
#   -- Copy/Link the commit hook: Try to autodetect standard setup.
    if (!defined $optCommitHook && $os != $OS_WINDOWS) {
       my $hook = $ENV{"HOME"} . '/dev/devtools/shell/git_post_commit_hook';
       $optCommitHook = $hook if -f $hook;
    }
#   -- Link or copy the hook according to platform.
    if (defined $optCommitHook) {
        my $target =File::Spec->catfile('.git', 'hooks' ,'post-commit');
        if (! -e $target) {
            print 'Setting up commit hook: ', $optCommitHook, ' ', $target,"\n";
            if ($os == $OS_WINDOWS) {
               execute('xcopy.exe', $optCommitHook, $target);
            } else {
                execute('ln', '-s', $optCommitHook, $target);
            }
        }
    }
    chdir($rootDir);
}

# --------------- Init gerrit

if (defined $optGerritModule) {
    my $scp = which('scp');
    $scp = msysGitUtility($git, 'scp') unless defined $scp || $os != $OS_WINDOWS;
    die ('Unable to locate scp.') unless defined $scp;
    die ('This option requires a codereview-user name') if $codeReviewUser eq '';
    chdir($optGerritModule) or die ('Failed to chdir from' . $rootDir . ' to "' . $optGerritModule);
    my $remoteRepo = $codeReviewUser . '@' . $codeReviewHost . ':qt/' . $optGerritModule;
    print 'Configuring ', $remoteRepo, "\n";
    my $grc = execute($git, ('config', 'remote.origin.url',  $remoteRepo));
    die 'Config failed'  if ($grc);
    print 'Initializing hooks', "\n";
    $grc = execute($scp, ('-p',  $codeReviewUser . '@' . $codeReviewHost . ':hooks/commit-msg', '.git/hooks'));
    die 'Copying of commit hook failed'  if ($grc);
    print 'Fetch all...', "\n";
    $grc = execute($git, ('fetch', '--all'));
    chdir($rootDir);
}

# --------------- Clean if desired

if ( $CLEAN !=  0 ) {
  print 'Cleaning Qt 5 in ',$rootDir,"\n";
  my @cleanArgs = ('clean','-dxf');
  executeCheck($git, @cleanArgs);
  runGit(\@cleanArgs);
}

# ---- Pull: Switch to branch unless there is one (check preferred
#      branch hash, default to branch n+1, which is mostly master).

if ( $PULL !=  0 ) {
    print 'Pulling Qt 5 in ',$rootDir,"\n";
    my $prc = execute($git, ('pull'));
    die 'Pull failed'  if ($prc);
    foreach my $MOD (@MODULES) {
        print 'Examining: ', $MOD, ' url: ',readGitConfig($MOD, 'url'), ' ';
        chdir($MOD) or die ('Failed to chdir from' . $rootDir . ' to "' . $MOD . '":' . $!);
        checkoutInitialBranch($MOD);
        print 'Pulling ', $MOD, "\n";
        $prc = execute($git, ('pull'));
        die 'Pull ' . $MOD . ' failed'  if ($prc);
        chdir($rootDir);
   } # foreach
} # pull

# --------------- Rebuild configure.exe
if ( $REBUILD_CONFIGURE !=  0 ) {
    rebuildConfigure($rootDir);
}

# ---- Update

if ( $UPDATE !=  0 ) {
    print 'Updating Qt 5 in ',$rootDir,"\n";
    my $urc = execute($git, ('pull'));
    die 'pull failed'  if ($urc);
    $urc = execute($git, ('submodule', 'update'));
    die 'update failed'  if ($urc);
}

# ---- Configure and build

if ( $BUILD !=  0 ) {
    print 'Building Qt 5 in ',$rootDir,"\n";
    winRemoveGitFromPath() if $minGW;
    my @configureArguments = ('-prefix', File::Spec->catfile($rootDir, 'qtbase'));
    my $configureArgumentsFromConfig = readQt5ToolConfig('configureArguments');
    push(@configureArguments, split(/ /, $configureArgumentsFromConfig)) unless $configureArgumentsFromConfig eq '';
#   --- Shadow builds: Remove and re-create directory
    my $shadowBuildDir = shadowBuildFolder();
    if ($shadowBuildDir ne '') {
        print 'Shadow build: "', $shadowBuildDir,"\"\n";
        if (-d $shadowBuildDir) {
            File::Path::rmtree($shadowBuildDir) or die ('Unable to remove ' . $shadowBuildDir . ' :' . $!);
        }
        mkdir($shadowBuildDir) or die  ('Unable to create ' . $shadowBuildDir . ' :' . $!);
        chdir($shadowBuildDir) or die  ('Unable to chdir ' . $shadowBuildDir . ' :' . $!);
    }
#   ---- Configure and build
    my $brc = execute(File::Spec->catfile($rootDir, 'configure'), @configureArguments);
    die 'Configure failed'  if ($brc);
#   --- Workaround: The module .pri files are currently (as of 30.9.2011) not copied to their
#       target location on Windows.
    if ($os == $OS_WINDOWS) {
        my $targetProfileFolder = File::Spec->catfile($rootDir, 'qtbase', 'mkspecs', 'modules');
        foreach my $module (@MODULES) {
            my $sourceProfilePattern = File::Spec->catfile($rootDir, $module, 'modules' , '*.pri');
            foreach my $sourceProfile (glob($sourceProfilePattern)) {
                my $baseName = basename($sourceProfile);
                if (index($baseName, 'jsondb') < 0 && index($baseName, 'compositor') < 0) {
                    my $target = File::Spec->catfile($targetProfileFolder, basename($sourceProfile));
                    if ( ! -f $target) {
                        print 'Workaround: Copying ', $sourceProfile, ' to ',$target,"\n";
                        File::Copy::copy($sourceProfile, $targetProfileFolder) or die ('Copy error '. $!);
                    }
                }
            }
        }
   }
} # BUILD

if ( $BUILD + $MAKE !=  0) {
    if ($BUILD == 0) { # Did not go through configure, cd
        my $makeShadowBuildDir = shadowBuildFolder();
        if ($makeShadowBuildDir ne '') {
            print 'Shadow build: "', $makeShadowBuildDir,"\"\n";
            chdir($makeShadowBuildDir) or die  ('Unable to chdir ' . $makeShadowBuildDir . ' :' . $!);
        }
    }
#   Run a global make. If that fails, check if a list of 'force modules' is configured and build them with -k
    my $makeRc = execute($make, @makeArgs);
    if ($makeRc) {
        $exitCode = 1;
        my @forcedModules = forceModules();
        die ($make . ' failed')  if @forcedModules == 0;
        warn ('######' . $make . ' failed, resorting to forcibly building ' . join(',', @forcedModules))  if ($makeRc);
        push(@makeArgs, $makeForceArg);
        foreach my $MOD (@forcedModules) {
            chdir($MOD) or die ('Failed to chdir from' . $rootDir . ' to "' . $MOD . '":' . $!);
            my $subMakeRc = execute($make, @makeArgs);
            warn ('######' . $make . ' failed in ' . $MOD . '.')  if ($subMakeRc);
            chdir($rootDir);
        }
    }
}

# ---- Untested: Build documentation.

if ($DOC !=  0 ) {
   print 'Documenting Qt 5 in ',$rootDir,"\n";
   my $drc = execute($make, (@makeArgs,'docs'));
   die ($make . ' docs failed')  if ($drc);
}

exit($exitCode);
