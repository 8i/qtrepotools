#!/usr/bin/perl -w
####################################################################################################
#
# Helper script for Qt 5
#
# Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
# Contact: Nokia Corporation (qt-info@nokia.com)
#
####################################################################################################

############################################################################################
#
# Convenience script working with a Qt 5 repository.
#
# Feel free to add useful options!
#
# The intention is that this works with the old Perl used for Symbian as well:
# - Variables should not shadow others.
# - Some functions are just broken  (abs_path()),etc.
############################################################################################

use strict;

use Getopt::Long;
use File::Basename;
use Cwd;
use File::Spec;
use POSIX;
use IO::File;
use File::Path;

my $CLEAN=0;
my $DOC=0;
my $PULL=0;
my $BUILD=0;
my $MAKE=0;
my $RESET=0;
my $DIFF=0;
my $BOOTSTRAP=0;
my $STATUS=0;
my $optModuleBranchArgument;
my $optGerritModule;
my $optCommitHook;
my $configFile = '.qt5_tool';
my $codeReviewHost = 'codereview.qt.nokia.com';
my $codeReviewPort = 29418;

my $USAGE=<<EOF;
Usage: qt5_tool [OPTIONS]

Utility script for working with Qt 5 modules.

Feel free to extend!

Options:
  -d  Diff (over all modules, relative to root)
  -u  Status
  -r  Reset hard
  -c  Clean
  -p  Pull
  -b  Build (configure + build)
  -m  Make
  -o  [D]ocumentation
  -q  Quick bootstrap a new checkout under current folder. Before doing that
      for the first time, a configuration file \$HOME/$configFile
      should be created containing the arguments to init-repository and
      the user name for code review (see below).
  -g <module> Set up gerrit for the module.
  -s <module> Set up a tracking branch for the module. By default, this is
              staging/master. It is possible the specify the branch by appending
              :remote-branch to the module parameter, for example:
              qtbase:origin/refactor
  -h <hook>   Path to commit hook for -s.

Example use cases:
  qt5_tool -c -p -b     Clean, pull and build for nightly builds
  qt5_tool -d           Generate modules diff relative to root directory
  qt5_tool -r           Reset --hard of repo.

qt_tool can be configured by creating a configuration file \$HOME/$configFile in
the format key=value. It is possible to use repository-specific values by
adding a key postfixed by a dash and the repository folder base name.
Supported keys:

initArguments:      Arguments to init-repository for -q. Example:
                    [--berlin-|--brisbane-|--]nokia-developer
codeReviewUser:     User name for code review (Gerrit)
configureArguments: Arguments to configure
shadowBuildPostfix: Postfix to use for shadow build directory.
forceModules:       A list of modules (like "qtbase qtscript") that will be
                    built using 'make -k' if the global 'make' fails.

Example:
shadowBuildPostfix=-build
shadowBuildPostfix-qt-5special=-special-build

specifies that for a checkout in '/home/user/qt-5', shadow builds are to be
done in '/home/user/qt-5-build'. It is overridden by a value for the checkout
'/home/user/qt-5special', which would result in '/home/user/qt-5-special-build'
EOF

my %preferredBranches = (
#    'qtwebkit' , 'qt-modularization-base'
);

# --------------- Detect OS

my ($OS_LINUX, $OS_WINDOWS, $OS_MAC)  = (0, 1, 2);
my $os = $OS_LINUX;
if (index($^O, 'MSWin') >= 0) {
    $os = $OS_WINDOWS;
} elsif (index($^O, 'darwin') >= 0) {
   $os = $OS_MAC;
}

my $qmakeSpec = $ENV{'QMAKESPEC'};
my $minGW = $os == $OS_WINDOWS && defined($qmakeSpec) && index($qmakeSpec,'g++') > 0;
my $make = 'make';
$make = $minGW ?  'mingw32-make' : 'nmake' if ($os == $OS_WINDOWS);

my @makeArgs = $os == $OS_WINDOWS && !$minGW ? () : ('-s');
my $scp = $os == $OS_WINDOWS ? 'pscp' : 'scp';
my $makeForceArg = $os == $OS_WINDOWS && !$minGW ? '/k' : '-k';
my $git = 'git'; # TODO: Mac, Windows special cases?

my $rootDir = '';
my $baseDir = '';
my $home = $os == $OS_WINDOWS ? ($ENV{'HOMEDRIVE'} . $ENV{'HOMEPATH'}) : $ENV{'HOME'};

my @MODULES = ();

# Move this to configuration file for general use?
my $nokiaDeveloper = 1;

# --- Fix a diff line from a submodule such that it can be applied to
#     the root Qt 5 directory, that is:
#     '--- a/foo...' -> '--- a/<module>/foo...'

sub fixDiff
{
   my ($line, $module) = @_;
   if (index($line, '--- a/') == 0 || index($line, '+++ b/') == 0) {
       return substr($line, 0, 6) . $module . '/' . substr($line, 6);
   }
   if (index($line, 'diff --git ') == 0) {
       $line =~ s| a/| a/$module/|;
       $line =~ s| b/| b/$module/|;
   }
   return $line;
}

# ---- Generate a diff from all submodules such that it can be applied to
#      the root Qt 5 directory.

sub diff
{
    my $totalDiff = '';
    my ($rootDir,$modArrayRef) = @_;
    foreach my $MOD (@$modArrayRef) {
     chdir($MOD) or die ('Failed to chdir from' . $rootDir . ' to "' . $MOD . '":' . $!);
     my $diffOutput = `$git diff`;
     foreach my $line (split(/\n/, $diffOutput)) {
         chomp($line);
         $totalDiff .= fixDiff($line, $MOD);
         $totalDiff .= "\n";
     }
     chdir($rootDir);
  }
  return $totalDiff;
}

# ---- Run git in root and module folders.
#      Do not use 'git submodules foreach' to be able to work on partially corrupt repositories

sub runGit
{
    my ($argListRef, $keepGoing) = @_;
    my $argString = join(' ', @$argListRef);
    print 'Running ', $argString, "\n";
    my $runRC = system($git, @$argListRef);
    if ($runRC) {
       if ($keepGoing) {
          warn($argString . ' failed in root.');
       } else {
          die ($argString . ' failed in root.');
       }
    }
    foreach my $MOD (@MODULES) {
        chdir($MOD) or die ('Failed to chdir from' . $rootDir . ' to "' . $MOD . '":' . $!);
        print 'Running ', @$argListRef, ' in ', $MOD,"\n";
        my $modRunRC = system($git, @$argListRef);
        if ($modRunRC) {
            if ($keepGoing) {
                warn($argString . ' failed in ' . $MOD);
            } else {
               die ($argString . ' failed in ' . $MOD);
            }
           $runRC = 1;
        }
        chdir($rootDir);
    }
    return $runRC;
}

# ---- Read a value from a configuration file of the form key=value.

sub readConfigFile
{
    my ($fileName, $key) = @_;

    my $configLine = '';
    my $configFile = new IO::File('<' . $fileName) or return $configLine;
    while (my $line = <$configFile>) {
        chomp($line);
        if ($line =~ /^\s*$key\s*=\s*(.*)$/) {
           $configLine .= $1;
           last;
        }
    }
    $configFile->close();
    return $configLine;
}

# ---- Read a value from a git config line.

sub readGitConfig
{
    my ($module, $key) = @_;
    return readConfigFile(File::Spec->catfile($rootDir, $module, '.git', 'config'), $key);
}

# ---- MinGW: Remove git from path (prevent sh.exe from throwing off mingw32-make).

sub winRemoveGitFromPath
{
    my @path = split(/;/, $ENV{'PATH'});
    my @cleanPath = grep(!/git/, @path);
    if (@path != @cleanPath) {
	print 'Removing git from path...';
        $ENV{'PATH'} = join(';', @cleanPath);
    }
}

# ---- Set up a tracking branch
sub initTrackingBranch
{
    my ($branchName, $remoteBranchName) = @_;
    my $strc = system($git, ('fetch', '--all'));
    die 'fetch failed.' if $strc;
    print 'Switching to ', $branchName, ' from ', $remoteBranchName, "\n";
    $strc = system($git, ('branch', '--track', $branchName, $remoteBranchName));
    die 'branch ' . $branchName . ' ' . $remoteBranchName . ' failed.' if $strc;
    $strc = system($git, ('checkout', $branchName));
    die 'checkout failed.' if $strc;
}

# ---- Read a value from the '$HOME/.qt5_tool' configuration file
#      When given a key 'key' for the repository directory '/foo/qt-5',
#      check for the repo-specific value 'key-qt5' and then for the general
#      'key'.

sub readQt5ToolConfig
{
    my ($key) = @_;
    my $repoKey = $key . '-' . $baseDir;
    my $repoValue = readConfigFile(File::Spec->catfile($home, $configFile), $repoKey);
    return $repoValue if $repoValue ne '';
    return readConfigFile(File::Spec->catfile($home, $configFile), $key);
}

sub shadowBuildFolder
{
    my $shadowBuildPostfix = readQt5ToolConfig('shadowBuildPostfix');
    return $shadowBuildPostfix ne '' ? $rootDir . $shadowBuildPostfix : '';
}

# ---- Read a list of modules which will be built with -k if the global 'make' fails
sub forceModules()
{
    my $forceModules = readQt5ToolConfig('forceModules');
    return $forceModules ne '' ? split(/ /, $forceModules) : ();
}

# ---- Check for absolute path names.

sub isAbsolute
{
    my ($file) = @_;
    return index($file, ':') == 1 if ($os == $OS_WINDOWS);
    return index($file, '/') == 0;
}

# --------------- MAIN: Parse arguments

if (!GetOptions('clean' => \$CLEAN, 'ocumentation' => \$DOC,
     'pull' => \$PULL, 'reset' => \$RESET, 'diff' => \$DIFF, 'us' => \$STATUS,
     'build' => \$BUILD, 'make' => \$MAKE, 'staging=s' => \$optModuleBranchArgument,
     'gerrit=s' => \$optGerritModule,
     'hook=s' => \$optCommitHook, 'quick-bootstrap'  => \$BOOTSTRAP)
    || ($CLEAN + $DOC + $PULL + $BUILD + $MAKE + $RESET + $DIFF + $BOOTSTRAP + $STATUS == 0
        && ! defined $optModuleBranchArgument && !defined $optGerritModule)) {
    print $USAGE;
    exit (1);
}

my $codeReviewUser = readQt5ToolConfig('codeReviewUser');

# --------------- Bootstrap

if ( $BOOTSTRAP != 0 ) {
    my $repoURL = 'ssh://' . $codeReviewHost . ':' . $codeReviewPort .'/qt/qt5.git';
    my $targetFolder = 'qt-5';
    my @initOptions;
    push (@initOptions, '-nokia-developer') if $nokiaDeveloper;
    push (@initOptions, '--codereview-username=' . $codeReviewUser) if $codeReviewUser ne '';
    my $initArgumentsFromConfig = readQt5ToolConfig('initArguments');
#   -- Webkit is usually too slow to clone unless something is configured.
    if ($initArgumentsFromConfig ne '') {
        push(@initOptions, split(/ /, $initArgumentsFromConfig));
    } else {
        push(@initOptions, '--no-webkit');
    }
    my $toolsFolder = 'qtrepotools';
    # -- Clone
    my $cloneRc = system($git, ('clone', $repoURL, $targetFolder));
    die 'clone '. $repoURL  . ' failed.' if $cloneRc;
    chdir($targetFolder) or die ('Failed to chdir to "' . $targetFolder . '":' . $!);
    # -- Run init
    my $initRc = 0;
    if ($os == $OS_WINDOWS) {
        $initRc = system('perl', 'init-repository', @initOptions);
    } else {
        $initRc = system('./init-repository', @initOptions);
    }
    die 'init '. $repoURL  . ' failed.' if $initRc;
    # -- Checkout 'master' in repotools and run the qt5_tool there
    # to pull such that the branches are initialized.
    chdir($toolsFolder) or die ('Failed to chdir to tools folder:' . $!);
    my $checkoutMasterRc = system($git, ('checkout', 'master'));
    die 'checkout master in tools repository failed.' if $checkoutMasterRc;
    chdir('..');
    system(File::Spec->catfile($toolsFolder, 'bin', 'qt5_tool'), '-p');
    exit 0;
}

# --- Change to root: Assume we live in qtrepotools below root.
#     Note: Cwd::realpath is broken in the Symbian-perl-version.
my $prog = $0;
$prog = Cwd::realpath($0) unless isAbsolute($prog);
$rootDir = dirname(dirname(dirname($prog)));
$baseDir = basename($rootDir);
chdir($rootDir) or die ('Failed to chdir to' . $rootDir . '":' . $!);
my $exitCode = 0;
# ---- Determine modules by trying to find <module>/.git/config.

opendir (DIR, $rootDir) or die ('Cannot read ' . $rootDir . $!);
while (my $e = readdir(DIR)) {
   if ($e ne '.' && $e ne '..') {
       push(@MODULES, $e) if (-d $e && -f (File::Spec->catfile($e, '.git','config')));
   }
}
closedir(DIR);
die ('Failed to detect modules in ' . $rootDir . ".\nNeeds to be called from the root directory.") if @MODULES == 0;

print diff($rootDir, \@MODULES) if $DIFF;

# --------------- Reset: Save to a patch in HOME dir indicating date in
#                 file name should there be a diff.
if ( $RESET !=  0 ) {
  print 'Resetting Qt 5 in ',$rootDir,"\n";
  my $changes = diff($rootDir, \@MODULES);
  if ($changes ne '') {
     my $patch = File::Spec->catfile($home, POSIX::strftime('qt5_d%Y%m%d%H%M.patch',localtime));
     my $patchFile = new IO::File('>' . $patch) or die ('Unable to open for writing ' .  $patch . ' :' . $!);
     print $patchFile $changes;
     $patchFile->close();
     print 'Saved ', $patch, "\n";
  }
  my @resetArgs = ('reset','--hard');
  runGit(\@resetArgs, 1);
}

# --------------- Status.
if ( $STATUS !=  0 ) {
    my @branchArgs = ('branch', '-v');
    runGit(\@branchArgs, 1);
    my @statusArgs = ('status');
    runGit(\@statusArgs, 1);
}

# --------------- Switch to branch

if (defined $optModuleBranchArgument) {
#   -- Split arguments of form module[:origin/refactor]
    my ($branchName, $remoteBranchName ) = ('staging','staging/master');
    my $bColon = index($optModuleBranchArgument, ':');
    if ($bColon > 0) {
        $remoteBranchName = substr($optModuleBranchArgument, $bColon + 1);
        my $bSlash = index($remoteBranchName, '/');
        die ('Invalid remote branch name' . $remoteBranchName) if ($bSlash < 1);
        $branchName = substr($remoteBranchName, $bSlash + 1);
        $optModuleBranchArgument = substr($optModuleBranchArgument, 0, $bColon);
    }
    chdir($optModuleBranchArgument) or die ('Failed to chdir from' . $rootDir . ' to "' . $optModuleBranchArgument . '":' . $!);
    initTrackingBranch($branchName, $remoteBranchName);
#   -- Copy/Link the commit hook: Try to autodetect standard setup.
    if (!defined $optCommitHook && $os != $OS_WINDOWS) {
       my $hook = $ENV{"HOME"} . '/dev/devtools/shell/git_post_commit_hook';
       $optCommitHook = $hook if -f $hook;
    }
#   -- Link or copy the hook according to platform.
    if (defined $optCommitHook) {
        my $target =File::Spec->catfile('.git', 'hooks' ,'post-commit');
        if (! -e $target) {
            print 'Setting up commit hook: ', $optCommitHook, ' ', $target,"\n";
            if ($os == $OS_WINDOWS) {
               system('xcopy.exe', $optCommitHook, $target);
            } else {
                system('ln', '-s', $optCommitHook, $target);
            }
        }
    }
    chdir($rootDir);
}

# --------------- Init gerrit

if (defined $optGerritModule) {
    die ('This option requires a codereview-user name') if $codeReviewUser eq '';
    chdir($optGerritModule) or die ('Failed to chdir from' . $rootDir . ' to "' . $optGerritModule);
    my $remoteRepo = $codeReviewUser . '@' . $codeReviewHost . ':qt/' . $optGerritModule;
    print 'Configuring ', $remoteRepo, "\n";
    my $grc = system($git, ('config', 'remote.origin.url',  $remoteRepo));
    die 'Config failed'  if ($grc);
    print 'Initializing hooks', "\n";
    $grc = system($scp, ('-p',  $codeReviewUser . '@' . $codeReviewHost . ':hooks/commit-msg', '.git/hooks'));
    die 'Copying of commit hook failed'  if ($grc);
    print 'Fetch all...', "\n";
    $grc = system($git, ('fetch', '--all'));
    chdir($rootDir);
}

# --------------- Clean if desired

if ( $CLEAN !=  0 ) {
  print 'Cleaning Qt 5 in ',$rootDir,"\n";
  system($git, ('clean','-dxf'));
  system($git, ('submodule','foreach',$git,'clean','-dxf'));
}

# ---- Pull: Switch to branch unless there is one (check preferred
#      branch hash, default to branch n+1, which is mostly master).

if ( $PULL !=  0 ) {
  print 'Pulling Qt 5 in ',$rootDir,"\n";
  my $prc = system($git, ('pull'));
  die 'Pull failed'  if ($prc);
  foreach my $MOD (@MODULES) {
     print 'Examining: ', $MOD, ' url: ',readGitConfig($MOD, 'url'), ' ';
     chdir($MOD) or die ('Failed to chdir from' . $rootDir . ' to "' . $MOD . '":' . $!);
     my @branches = split("\n", `$git branch`);
     my @currentBranches = grep(/^\* /, @branches);
     die ('Unable to determine branch of ' . $MOD) if @currentBranches != 1;
     my $currentBranch = substr($currentBranches[0], 2);
     if ($currentBranch eq '(no branch)') {
        # Switch to suitable branch when none is set initially.
        my $desiredBranch = $preferredBranches{$MOD};
        $desiredBranch = substr($branches[1],2) unless defined $desiredBranch;
        die ('Unable to determine suitable branch for ' . $MOD) if not defined $desiredBranch;
        print 'Switching ',$MOD, ' from ', $currentBranch,' to ',$desiredBranch,"\n";
        my $rc = system($git, ('checkout', $desiredBranch));
        die 'Checkout of ' . $desiredBranch . ' failed'  if ($rc);
     } else {
        print ' branch: ',$currentBranch,"\n";
     }
     print 'Pulling ', $MOD, "\n";
     $prc = system($git, ('pull'));
     die 'Pull ' . $MOD . ' failed'  if ($prc);
     chdir($rootDir);
  }
}

# ---- Configure and build

if ( $BUILD !=  0 ) {
    print 'Building Qt 5 in ',$rootDir,"\n";
    winRemoveGitFromPath() if $minGW;
    my @configureArguments;
    push (@configureArguments, '-nokia-developer') if $nokiaDeveloper;
    push (@configureArguments, '-nomake', 'tests', '-nomake', 'demos', '-nomake examples');
#   -- detect X11
    push (@configureArguments, '-xcb') if defined $ENV{'DISPLAY'};
    my $configureArgumentsFromConfig = readQt5ToolConfig('configureArguments');
    push(@configureArguments, split(/ /, $configureArgumentsFromConfig)) unless $configureArgumentsFromConfig eq '';
#   --- Shadow builds: Remove and re-create directory
    my $shadowBuildDir = shadowBuildFolder();
    if ($shadowBuildDir ne '') {
        print 'Shadow build: "', $shadowBuildDir,"\"\n";
        if (-d $shadowBuildDir) {
            File::Path::rmtree($shadowBuildDir) or die ('Unable to remove ' . $shadowBuildDir . ' :' . $!);
        }
        mkdir($shadowBuildDir) or die  ('Unable to create ' . $shadowBuildDir . ' :' . $!);
        chdir($shadowBuildDir) or die  ('Unable to chdir ' . $shadowBuildDir . ' :' . $!);
    }
#   ---- Configure and build
    my $brc = system(File::Spec->catfile($rootDir, 'configure'), @configureArguments);
    die 'Configure failed'  if ($brc);
}

if ( $BUILD + $MAKE !=  0) {
    if ($BUILD == 0) { # Did not go through configure, cd
        my $makeShadowBuildDir = shadowBuildFolder();
        if ($makeShadowBuildDir ne '') {
            print 'Shadow build: "', $makeShadowBuildDir,"\"\n";
            chdir($makeShadowBuildDir) or die  ('Unable to chdir ' . $makeShadowBuildDir . ' :' . $!);
        }
    }
#   Run a global make. If that fails, check if a list of 'force modules' is configured and build them with -k
    my $makeRc = system($make, @makeArgs);
    if ($makeRc) {
        $exitCode = 1;
        my @forcedModules = forceModules();
        die ($make . ' failed')  if @forcedModules == 0;
        warn ('######' . $make . ' failed, resorting to forcibly building ' . join(',', @forcedModules))  if ($makeRc);
        push(@makeArgs, $makeForceArg);
        foreach my $MOD (@forcedModules) {
            chdir($MOD) or die ('Failed to chdir from' . $rootDir . ' to "' . $MOD . '":' . $!);
            my $subMakeRc = system($make, @makeArgs);
            warn ('######' . $make . ' failed in ' . $MOD . '.')  if ($subMakeRc);
            chdir($rootDir);
        }
    }
}

# ---- Untested: Build documentation.

if ($DOC !=  0 ) {
   print 'Documenting Qt 5 in ',$rootDir,"\n";
   my $drc = system($make, (@makeArgs,'docs'));
   die ($make . ' docs failed')  if ($drc);
}

exit($exitCode);
