#!/usr/bin/env perl
# Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).
# Contact: http://www.qt-project.org/legal
#
# You may use this file under the terms of the 3-clause BSD license.
# See the file LICENSE from this package for details.
#

use strict;
use warnings;

use File::Basename;

# Cannot use Pod::Usage for this file, since git on Windows will invoke its own perl version, which
# may not (msysgit for example) support this module, even if it's considered a Core module.
sub usage
{
    print << "EOM";
Usage:
    git gpush [opts] [remote] [[sha1/ref-from]:[ref-to]] [+<reviewer>] [=<CC user>] [-- <push opts>]

    Pushes changes to Gerrit and adds reviewers and CC to the patch
    sets

Description:
    This script is used to push patch sets to Gerrit, and at the same
    time add reviewers and CCs to the patch sets pushed.

    You can use email addresses, Gerrit usernames or aliases for the
    name of the reviewers/CCs. Aliases are read from the
        .git-gpush-aliases
    located next to the script, then from the git config which may
    have aliases set either locally in the current repository,
    globally (in your ~/.gitconfig), or system-wide.

    You can add aliases to your global git config like this:
        git config --global gpush.alias.<alias key> <alias value>
    and if you only want it to be local to the current repository,
    just drop the --global option.
    Note that git config keys are constrained regarding allowed
    characters, so it is impossible to map some IRC nicks via git
    configuration.

    An alias may contain multiple comma-separated email addresses;
    for example, to set a single alias for an entire team.

    Inside .git-gpush-aliases, each alias may also be a comma-separated
    list, in case a user uses multiple handles.

    If no sha1 or ref-from is specified or configured, 'HEAD' is used.
    You may configure a ref-from like this
        git config gpush.ref-from <ref-from value>

    If no ref-to is specified or configured, the remote tracking
    branch for 'ref-from' is used as
        'refs/for/<remote tracking branch>'.
    You may configure a ref-to like this
        git config gpush.ref-to <ref-from value>

    If no remote is specified or configured, 'gerrit' is used. You may
    configure a remote like this:
        git config gpush.remote <remote name>

    If all the options above have been populated, the remainder
    options are passed on directly to the normal 'git push' command.
    If you want to avoid specifying all options first, any options
    specified after a '--' are also passed on directly to the
    underlying 'git push' command. This can be particularly useful
    with the -n/--dry-run options, which make git do everything except
    actually sending the updates.

Options:
    -v, --verbose
        Shows the alias resolving, and external command invocations.

    --aliases
        Reports all registered aliases.

Copyright:
    Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).
    Contact: http://www.qt-project.org/legal

License:
    You may use this file under the terms of the 3-clause BSD license.
EOM
}

my $verbose = 0;

my $remote = "gerrit";
my $remote_override = 0;
my $ref_from = "HEAD";
my $ref_to = "";
my $ref_override = 0;

my %aliases = ();

my @reviewers = ();
my @CCs = ();

my @arguments = ();

sub format_cmd(@)
{
    return join(' ', map { /\s/ ? '"' . $_ . '"' : $_ } @_);
}

sub read_git_line(@)
{
    print "+ " . format_cmd('git', @_) . "\n" if ($verbose);
    open PROC, '-|', 'git', @_
        or die("Failed to run " . format_cmd('git', @_) . ": $!\n");
    my $line = <PROC>;
    if (defined($line)) {
        chomp $line ;
        print "- $line\n" if ($verbose);
    }
    close PROC;
    return $line;
}

sub parse_arguments(@)
{
    while (scalar @_) {
        my $arg = shift @_;

        if ($arg eq "-v" || $arg eq "--verbose") {
            $verbose = 1;
            push @arguments, $arg;
        } elsif ($arg eq "--aliases") {
            foreach my $key (sort(keys %aliases)) {
                print "$key = $aliases{$key}\n";
            }
            exit 0;
        } elsif ($arg eq "-?" || $arg eq "--?" || $arg eq "-h" || $arg eq "--help") {
            usage();
            exit 0;
        } elsif ($arg eq "--") {
            push @arguments, @_;
            return;
        } elsif ($arg =~ /^\+(.+)/) {
            push @reviewers, split(/,/, lookup_alias($1));
        } elsif ($arg =~ /^\=(.+)/) {
            push @CCs, split(/,/, lookup_alias($1));
        } elsif ($arg =~ /^\-(.+)/) {
            push @arguments, $arg;
        } elsif (!$remote_override || !$ref_override) {
            if ($arg =~ /(.*):(.*)/) {
                $ref_from = $1 if (defined $1 && $1 ne "");
                $ref_to = $2 if (defined $2 && $2 ne "");
                $ref_override = 1;
            } else {
                $remote = $arg;
                $remote_override = 1;
            }
        } else {
            push @arguments, $arg;
        }
    }
}

sub fileContents($)
{
    my ($filename) = @_;

    my @contents = "";
    my $fh;
    if (-e $filename && open($fh, "< $filename")) {
        @contents = <$fh>;
        close $fh;
    }
    return @contents;
}

sub load_aliases()
{
    my $script_path = dirname($0);

    # Read aliases from .git-gpush-aliases file
    foreach my $line (fileContents("$script_path/.git-gpush-aliases")) {
        chomp $line;
        $line =~ s,(#|//).*$,,;             # Remove any comments
        if ($line =~ /([^ ]+)\s*=\s*(\S+)/) {  # Capture the alias
            for my $alias (split(/,/, $1)) {
                $aliases{$alias} = $2;
            }
        }
    }

    # Read aliases and configurations from git config
    my @gitconfigs = `git config --get-regexp gpush.*`;
    return if ($?); # just return if no git configs for gpush

    foreach (@gitconfigs) {
        if (/^gpush\.remote (\w+)/) {
            $remote = $2;
        } elsif (/^gpush\.ref-from (.+)/) {
            $ref_from = $2;
        } elsif (/^gpush\.ref-to (.+)/) {
            $ref_to = $2;
        } elsif (/^gpush\.alias\.([^ ]*) (.+)/) {
            $aliases{$1} = $2;
        } # else ignore
    }
}

sub lookup_alias($)
{
    my ($user) = @_;

    my $alias = $aliases{$user};
    if (defined $alias && $alias ne "") {
        print " $user = $alias\n" if ($verbose);
        return $alias;
    }

    return $user;
}

sub add_reviewers()
{
    if (@reviewers || @CCs) {
        my @dudes = ();
        push @dudes, "--receive-pack=git receive-pack";
        push @dudes, map { " --reviewer=$_" } @reviewers;
        push @dudes, map { " --cc=$_" } @CCs;
        push @arguments, join('', @dudes); # Single argument to git push
    }
}

sub determine_target()
{
    # Detect tracking branch if ref-to is not set
    if ($ref_to eq "") {
        my $ref = $ref_from;
        $ref =~ s/[~^].*$//;
        my $sref = read_git_line("symbolic-ref", "-q", $ref);
        $ref = $sref if ($? == 0);
        $ref =~ s,^refs/heads/,,;
        read_git_line("rev-parse", "--verify", "-q", "refs/heads/".$ref);
        die "Cannot detect tracking branch, $ref is not a valid ref.\n" if ($? != 0);
        $ref_to = read_git_line("config", "branch.$ref.merge");
        die "Cannot detect tracking branch, 'git config branch.$ref.merge' failed.\n" if ($? != 0);
        $ref_to =~ s,^refs/heads/,,;
    }
    if ($ref_to =~ m,^refs/for/,) {
        print STDERR "Notice: it is unnecessary to specify refs/for/ in the target ref.\n";
    } else {
        $ref_to = "refs/for/".$ref_to;
    }
}

sub push_patches()
{
    my @gitcmd = ("git", "push");
    push @gitcmd, @arguments;
    push @gitcmd, $remote, "$ref_from:$ref_to";

    print '+ '.format_cmd(@gitcmd)."\n" if ($verbose);
    exit system(@gitcmd);
}

load_aliases();
parse_arguments(@ARGV);
add_reviewers();
determine_target();
push_patches();
